--- src/kernel/sel4/include/plat/pc99/plat/machine.h
+++ src/kernel/sel4/include/plat/pc99/plat/machine.h
@@ -51,8 +51,11 @@ typedef enum _irq_t {
 #define BIOS_PADDR_END   0x100000
 
 #define BIOS_PADDR_VIDEO_RAM_START 0x000A0000
+#define BIOS_PADDR_VIDEO_RAM_END   0x000B0000
 /* The text mode framebuffer exists part way into the video ram region */
 #define BIOS_PADDR_VIDEO_RAM_TEXT_MODE_START 0x000B8000
 #define BIOS_PADDR_IVDEO_RAM_END 0x000C0000
+#define BIOS_PADDR_VIDEO_BIOS_START 0x000C0000
+#define BIOS_PADDR_VIDEO_BIOS_END   0x000CF000
 
 #endif
--- src/kernel/sel4/src/arch/x86/kernel/boot_sys.c
+++ src/kernel/sel4/src/arch/x86/kernel/boot_sys.c
@@ -295,9 +295,11 @@ parse_mem_map(uint32_t mmap_length, uint32_t mmap_addr)
     multiboot_mmap_t *mmap = (multiboot_mmap_t *)((word_t)mmap_addr);
     printf("Parsing GRUB physical memory map\n");
 
+    p_region_t bios_area = { .start = BIOS_PADDR_START, .end = BIOS_PADDR_END };
+
     while ((word_t)mmap < (word_t)(mmap_addr + mmap_length)) {
-        uint64_t mem_start = mmap->base_addr;
-        uint64_t mem_length = mmap->length;
+        uint64_t mem_start = mmap->base_addr & ~0xFFFUL;
+        uint64_t mem_length = (mmap->length + (mmap->base_addr & 0xFFFUL)) & ~0xFFFUL;
         uint32_t type = mmap->type;
         if (mem_start != (uint64_t)(word_t)mem_start) {
             printf("\tPhysical memory region not addressable\n");
@@ -308,9 +310,48 @@ parse_mem_map(uint32_t mmap_length, uint32_t mmap_addr)
                     mem_start, mem_start + mem_length
                 });
             }
+            if (type == MULTIBOOT_MMAP_RESERVED_TYPE ||
+                type == MULTIBOOT_MMAP_ACPI_TYPE ||
+                type == MULTIBOOT_MMAP_ACPI_NVS_TYPE) {
+                p_region_t reg = { .start = mem_start, .end = mem_start + mem_length};
+
+                bool_t const inside_start = bios_area.start <= reg.start && reg.start < bios_area.end;
+                bool_t const inside_end   = bios_area.start < reg.end && reg.end <= bios_area.end;
+
+                /* trim BIOS area if we detect overlaps */
+                if (!inside_start && !inside_end &&
+                    (reg.start <= bios_area.start && bios_area.start < reg.end))
+                    bios_area.start = bios_area.end;
+                else
+                if (inside_start && inside_end) {
+                    p_region_t tail = { .start = reg.end, .end = bios_area.end };
+                    if (tail.start < tail.end)
+                        insert_dev_p_reg(tail);
+
+                    bios_area.end = reg.start;
+                } else {
+                    if (inside_start)
+                        bios_area.end = reg.start;
+                    if (inside_end)
+                        bios_area.start = reg.end;
+                }
+
+                insert_dev_p_reg(reg);
+            }
         }
         mmap++;
     }
+
+    /* first physical page - required by acpi drivers and vesa drivers */
+    insert_dev_p_reg((p_region_t) { .start = 0, .end = 0x1000 });
+
+    /* bios data area - required by acpi drivers */
+    if (bios_area.start < bios_area.end)
+        insert_dev_p_reg(bios_area);
+
+    /* vesa driver requires the regions */
+    insert_dev_p_reg((p_region_t) { .start = BIOS_PADDR_VIDEO_BIOS_START, .end = BIOS_PADDR_VIDEO_BIOS_END });
+    insert_dev_p_reg((p_region_t) { .start = BIOS_PADDR_VIDEO_RAM_START, .end = BIOS_PADDR_VIDEO_RAM_END });
 }
 
 static BOOT_CODE bool_t
@@ -349,6 +390,9 @@ try_boot_sys(
     /* copy CPU bootup code to lower memory */
     memcpy((void*)BOOT_NODE_PADDR, boot_cpu_start, boot_cpu_end - boot_cpu_start);
 
+    /* Prepare for accepting device regions from here on */
+    boot_state.dev_p_regs.count = 0;
+
     boot_state.mem_p_regs.count = 0;
     if (mbi->flags & MULTIBOOT_INFO_MMAP_FLAG) {
         parse_mem_map(mbi->mmap_length, mbi->mmap_addr);
@@ -378,9 +422,6 @@ try_boot_sys(
         pic_disable();
     }
 
-    /* Prepare for accepting device regions from here on */
-    boot_state.dev_p_regs.count = 0;
-
     /* get ACPI root table */
     acpi_rsdt = acpi_init();
     if (!acpi_rsdt) {
