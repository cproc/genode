gdbserver_genode.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 gdb/common/common-defs.h          |    8 +-
 gdb/gdbserver/linux-aarch32-low.c |    4 +
 gdb/gdbserver/linux-arm-low.c     |    8 ++
 gdb/gdbserver/linux-low.c         |  177 ++++++++++++++++++++++++++++++++++++-
 gdb/gdbserver/linux-low.h         |    5 +
 gdb/gdbserver/linux-x86-low.c     |  130 ++++++++++++++++++++++++++-
 gdb/gdbserver/linux-x86-tdesc.h   |   22 +++++
 gdb/gdbserver/remote-utils.c      |   11 ++
 gdb/gdbserver/server.c            |   29 +++++-
 gdb/nat/gdb_ptrace.h              |    2 
 gdb/nat/linux-ptrace.c            |   14 +++
 gdb/nat/linux-ptrace.h            |    4 +
 12 files changed, 396 insertions(+), 18 deletions(-)

diff --git a/gdb/common/common-defs.h b/gdb/common/common-defs.h
index 703dd02..9095050 100644
--- a/gdb/common/common-defs.h
+++ b/gdb/common/common-defs.h
@@ -22,7 +22,9 @@
 
 #include "config.h"
 #ifdef GDBSERVER
+#ifndef __GENODE__
 #include "build-gnulib-gdbserver/config.h"
+#endif /* __GENODE__ */
 #else
 #include "build-gnulib/config.h"
 #endif
@@ -53,9 +55,11 @@
 #include <strings.h>	/* for strcasecmp and strncasecmp */
 #endif
 #include <errno.h>
+#ifndef __GENODE__
 #include <alloca.h>
-
+#endif /* __GENODE__ */
 #include "ansidecl.h"
+#ifndef __GENODE__
 /* This is defined by ansidecl.h, but we prefer gnulib's version.  On
    MinGW, gnulib might enable __USE_MINGW_ANSI_STDIO, which may or not
    require use of attribute gnu_printf instead of printf.  gnulib
@@ -63,7 +67,7 @@
    is compatible with ATTRIBUTE_PRINTF, simply use it.  */
 #undef ATTRIBUTE_PRINTF
 #define ATTRIBUTE_PRINTF _GL_ATTRIBUTE_FORMAT_PRINTF
-
+#endif /* __GENODE__ */
 #include "libiberty.h"
 #include "pathmax.h"
 #include "gdb/signals.h"
diff --git a/gdb/gdbserver/linux-aarch32-low.c b/gdb/gdbserver/linux-aarch32-low.c
index feb28dd..d2d9fe9 100644
--- a/gdb/gdbserver/linux-aarch32-low.c
+++ b/gdb/gdbserver/linux-aarch32-low.c
@@ -35,7 +35,11 @@
    is used for gdbserver, so single threaded debugging should work
    OK, but for multi-threaded debugging we only insert the current
    ABI's breakpoint instruction.  For now at least.  */
+#ifdef __GENODE__
+#define arm_eabi_breakpoint 0xe7ffdefeUL
+#else
 #define arm_eabi_breakpoint 0xe7f001f0UL
+#endif
 
 #if (defined __ARM_EABI__ || defined __aarch64__)
 static const unsigned long arm_breakpoint = arm_eabi_breakpoint;
diff --git a/gdb/gdbserver/linux-arm-low.c b/gdb/gdbserver/linux-arm-low.c
index b2b2258..e394032 100644
--- a/gdb/gdbserver/linux-arm-low.c
+++ b/gdb/gdbserver/linux-arm-low.c
@@ -30,6 +30,9 @@
 #include <elf.h>
 #endif
 #include "nat/gdb_ptrace.h"
+#ifdef __GENODE__
+#include <sys/procfs.h>
+#endif
 #include <signal.h>
 #include <sys/syscall.h>
 
@@ -865,6 +868,10 @@ arm_read_description (void)
   /* Query hardware watchpoint/breakpoint capabilities.  */
   arm_linux_init_hwbp_cap (pid);
 
+#ifndef __GENODE__
+
+  /* Genode: 'init_registers_arm_with_*()' functions not generated */
+
   if (arm_get_hwcap (&arm_hwcap) == 0)
     return tdesc_arm;
 
@@ -897,6 +904,7 @@ arm_read_description (void)
 
       return result;
     }
+#endif
 
   /* The default configuration uses legacy FPA registers, probably
      simulated.  */
diff --git a/gdb/gdbserver/linux-low.c b/gdb/gdbserver/linux-low.c
index 3a9a522..fdb7968 100644
--- a/gdb/gdbserver/linux-low.c
+++ b/gdb/gdbserver/linux-low.c
@@ -27,6 +27,11 @@
 #include "nat/linux-waitpid.h"
 #include "gdb_wait.h"
 #include "nat/gdb_ptrace.h"
+
+#ifdef __GENODE__
+#include "genode-low.h"
+#endif
+
 #include "nat/linux-ptrace.h"
 #include "nat/linux-procfs.h"
 #include "nat/linux-personality.h"
@@ -693,7 +698,11 @@ handle_extended_wait (struct lwp_info **orig_event_lwp, int wstat)
       /* Set the event status.  */
       event_lwp->waitstatus.kind = TARGET_WAITKIND_EXECD;
       event_lwp->waitstatus.value.execd_pathname
+#ifdef __GENODE__
+    = xstrdup ("target");
+#else
 	= xstrdup (linux_proc_pid_to_exec_file (lwpid_of (event_thr)));
+#endif
 
       /* Mark the exec status as pending.  */
       event_lwp->stopped = 1;
@@ -942,9 +951,10 @@ linux_create_inferior (char *program, char **allargs)
   struct lwp_info *new_lwp;
   int pid;
   ptid_t ptid;
+#ifndef __GENODE__
   struct cleanup *restore_personality
     = maybe_disable_address_space_randomization (disable_randomization);
-
+#endif /* __GENODE__ */
 #if defined(__UCLIBC__) && defined(HAS_NOMMU)
   pid = vfork ();
 #else
@@ -974,9 +984,9 @@ linux_create_inferior (char *program, char **allargs)
 	      /* Errors ignored.  */;
 	    }
 	}
-
+#ifndef __GENODE__
       restore_original_signals_state ();
-
+#endif /* __GENODE__ */
       execv (program, allargs);
       if (errno == ENOENT)
 	execvp (program, allargs);
@@ -986,9 +996,9 @@ linux_create_inferior (char *program, char **allargs)
       fflush (stderr);
       _exit (0177);
     }
-
+#ifndef __GENODE__
   do_cleanups (restore_personality);
-
+#endif /* __GENODE__ */
   linux_add_process (pid, 0);
 
   ptid = ptid_build (pid, pid, 0);
@@ -1026,12 +1036,17 @@ linux_attach_lwp (ptid_t ptid)
   struct lwp_info *new_lwp;
   int lwpid = ptid_get_lwp (ptid);
 
+#ifndef __GENODE__
   if (ptrace (PTRACE_ATTACH, lwpid, (PTRACE_TYPE_ARG3) 0, (PTRACE_TYPE_ARG4) 0)
       != 0)
     return errno;
+#endif
 
   new_lwp = add_lwp (ptid);
 
+#ifdef __GENODE__
+  new_lwp->stopped = 1;
+#else
   /* We need to wait for SIGSTOP before being able to make the next
      ptrace call on this LWP.  */
   new_lwp->must_set_ptrace_flags = 1;
@@ -1098,6 +1113,7 @@ linux_attach_lwp (ptid_t ptid)
      end of the list, and so the new thread has not yet reached
      wait_for_sigstop (but will).  */
   new_lwp->stop_expected = 1;
+#endif
 
   return 0;
 }
@@ -1168,6 +1184,7 @@ linux_attach (unsigned long pid)
 
   proc = linux_add_process (pid, 1);
 
+#ifndef __GENODE__
   /* Don't ignore the initial SIGSTOP if we just attached to this
      process.  It will be collected by wait shortly.  */
   initial_thread = find_thread_ptid (ptid_build (pid, pid, 0));
@@ -1215,6 +1232,7 @@ linux_attach (unsigned long pid)
       gdb_assert (proc->tdesc != NULL);
     }
 
+#endif
   return 0;
 }
 
@@ -1483,14 +1501,21 @@ get_detach_signal (struct thread_info *thread)
 
 /* Detach from LWP.  */
 
+#ifdef __GENODE__
+void
+#else
 static void
+#endif /* __GENODE__ */
 linux_detach_one_lwp (struct lwp_info *lwp)
 {
   struct thread_info *thread = get_lwp_thread (lwp);
+#ifndef __GENODE__
   int sig;
+#endif /* __GENODE__ */
   int lwpid;
 
   /* If there is a pending SIGSTOP, get rid of it.  */
+#ifndef __GENODE__
   if (lwp->stop_expected)
     {
       if (debug_threads)
@@ -1500,7 +1525,9 @@ linux_detach_one_lwp (struct lwp_info *lwp)
       kill_lwp (lwpid_of (thread), SIGCONT);
       lwp->stop_expected = 0;
     }
+#endif
 
+#ifndef __GENODE__
   /* Pass on any pending signal for this thread.  */
   sig = get_detach_signal (thread);
 
@@ -1563,6 +1590,7 @@ linux_detach_one_lwp (struct lwp_info *lwp)
 		    target_pid_to_str (ptid_of (thread)),
 		    strsignal (sig));
     }
+#endif
 
   delete_lwp (lwp);
 }
@@ -1918,6 +1946,7 @@ iterate_over_lwps (ptid_t filter,
 static void
 check_zombie_leaders (void)
 {
+#ifndef __GENODE__
   struct process_info *proc, *tmp;
 
   ALL_PROCESSES (proc, tmp)
@@ -1976,6 +2005,7 @@ check_zombie_leaders (void)
 	  delete_lwp (leader_lp);
 	}
     }
+#endif /* __GENODE__ */
 }
 
 /* Callback for `find_inferior'.  Returns the first LWP that is not
@@ -2775,11 +2805,13 @@ linux_wait_for_event_filtered (ptid_t wait_ptid, ptid_t filter_ptid,
 
       if (ret > 0)
 	{
+#ifndef __GENODE__
 	  if (debug_threads)
 	    {
 	      debug_printf ("LLW: waitpid %ld received %s\n",
 			    (long) ret, status_to_str (*wstatp));
 	    }
+#endif /* __GENODE__ */
 
 	  /* Filter all events.  IOW, leave all events pending.  We'll
 	     randomly select an event LWP out of all that have events
@@ -3127,11 +3159,12 @@ linux_stabilize_threads (void)
 static ptid_t
 ignore_event (struct target_waitstatus *ourstatus)
 {
+#ifndef __GENODE__
   /* If we got an event, there may still be others, as a single
      SIGCHLD can indicate more than one child stopped.  This forces
      another target_wait call.  */
   async_file_mark ();
-
+#endif /* __GENODE__ */
   ourstatus->kind = TARGET_WAITKIND_IGNORE;
   return null_ptid;
 }
@@ -3931,9 +3964,11 @@ linux_wait (ptid_t ptid,
 {
   ptid_t event_ptid;
 
+#ifndef __GENODE__
   /* Flush the async file first.  */
   if (target_is_async_p ())
     async_file_flush ();
+#endif
 
   do
     {
@@ -3943,12 +3978,14 @@ linux_wait (ptid_t ptid,
 	 && ptid_equal (event_ptid, null_ptid)
 	 && ourstatus->kind == TARGET_WAITKIND_IGNORE);
 
+#ifndef __GENODE__
   /* If at least one stop was reported, there may be more.  A single
      SIGCHLD can signal more than one child stop.  */
   if (target_is_async_p ()
       && (target_options & TARGET_WNOHANG) != 0
       && !ptid_equal (event_ptid, null_ptid))
     async_file_mark ();
+#endif
 
   return event_ptid;
 }
@@ -3958,6 +3995,9 @@ linux_wait (ptid_t ptid,
 static int
 kill_lwp (unsigned long lwpid, int signo)
 {
+#ifdef __GENODE__
+  return kill (lwpid, signo);
+#else
   int ret;
 
   errno = 0;
@@ -3969,6 +4009,7 @@ kill_lwp (unsigned long lwpid, int signo)
       perror_with_name (("tkill"));
     }
   return ret;
+#endif
 }
 
 void
@@ -4504,6 +4545,21 @@ linux_resume_one_lwp_throw (struct lwp_info *lwp,
   regcache_invalidate_thread (thread);
   errno = 0;
   lwp->stepping = step;
+
+#ifdef __GENODE__
+
+  /*
+   * On Linux, the thread would get stopped immediately after resuming
+   * if a SIGSTOP is pending. This is not the case on Genode, so we
+   * just keep the thread stopped.
+   */
+  if (lwp->stop_expected)
+	return;
+
+  genode_continue_thread(lwpid_of(thread), step);
+
+#else
+
   if (step)
     ptrace_request = PTRACE_SINGLESTEP;
   else if (gdb_catching_syscalls_p (lwp))
@@ -4516,6 +4572,7 @@ linux_resume_one_lwp_throw (struct lwp_info *lwp,
 	  /* Coerce to a uintptr_t first to avoid potential gcc warning
 	     of coercing an 8 byte integer to a 4 byte pointer.  */
 	  (PTRACE_TYPE_ARG4) (uintptr_t) signal);
+#endif
 
   current_thread = saved_thread;
   if (errno)
@@ -4553,7 +4610,7 @@ check_ptrace_stopped_lwp_gone (struct lwp_info *lp)
      (observed in Linux 3.18).  See also the note on ESRCH in the
      ptrace(2) man page.  Instead, check whether the LWP has any state
      other than ptrace-stopped.  */
-
+#ifndef __GENODE__
   /* Don't assume anything if /proc/PID/status can't be read.  */
   if (linux_proc_pid_is_trace_stopped_nowarn (lwpid_of (thread)) == 0)
     {
@@ -4561,6 +4618,7 @@ check_ptrace_stopped_lwp_gone (struct lwp_info *lp)
       lp->status_pending_p = 0;
       return 1;
     }
+#endif /* __GENODE__ */
   return 0;
 }
 
@@ -5402,6 +5460,7 @@ regsets_fetch_inferior_registers (struct regsets_info *regsets_info,
 		 this process mode.  */
 	      disable_regset (regsets_info, regset);
 	    }
+#ifndef __GENODE__
 	  else if (errno == ENODATA)
 	    {
 	      /* ENODATA may be returned if the regset is currently
@@ -5414,6 +5473,7 @@ regsets_fetch_inferior_registers (struct regsets_info *regsets_info,
 		 already gone, in which case we simply ignore attempts
 		 to read its registers.  */
 	    }
+#endif
 	  else
 	    {
 	      char s[256];
@@ -6602,6 +6662,13 @@ linux_read_loadmap (const char *annex, CORE_ADDR offset,
 static void
 linux_process_qsupported (char **features, int count)
 {
+#ifdef __GENODE__
+  /*
+   * 'qSupported' is the first command sent by GDB when attaching to the
+   * server, so when at this location, GDB has just (re-)attached itself.
+   */
+  genode_stop_all_threads();
+#endif
   if (the_low_target.process_qsupported != NULL)
     the_low_target.process_qsupported (features, count);
 }
@@ -6727,6 +6794,7 @@ linux_get_min_fast_tracepoint_insn_len (void)
   return (*the_low_target.get_min_fast_tracepoint_insn_len) ();
 }
 
+#ifndef __GENODE__
 /* Extract &phdr and num_phdr in the inferior.  Return 0 on success.  */
 
 static int
@@ -7236,6 +7304,7 @@ linux_qxfer_libraries_svr4 (const char *annex, unsigned char *readbuf,
 
   return len;
 }
+#endif /* __GENODE__ */
 
 #ifdef HAVE_LINUX_BTRACE
 
@@ -7503,25 +7572,52 @@ static struct target_ops linux_target_ops = {
   linux_create_inferior,
   linux_post_create_inferior,
   linux_attach,
+#ifndef __GENODE__
   linux_kill,
   linux_detach,
   linux_mourn,
   linux_join,
+#else
+  genode_kill,
+  genode_detach,
+  NULL,
+  NULL,
+#endif
   linux_thread_alive,
   linux_resume,
   linux_wait,
+#ifndef __GENODE__
   linux_fetch_registers,
   linux_store_registers,
+#else
+  genode_fetch_registers,
+  genode_store_registers,
+#endif
   linux_prepare_to_access_memory,
   linux_done_accessing_memory,
+#ifndef __GENODE__
   linux_read_memory,
   linux_write_memory,
+#else
+  genode_read_memory,
+  genode_write_memory,
+#endif
+#ifndef __GENODE__
   linux_look_up_symbols,
+#else
+  NULL,
+#endif
   linux_request_interrupt,
+#ifndef __GENODE__
   linux_read_auxv,
   linux_supports_z_point_type,
+#else
+  NULL,
+  NULL,
+#endif
   linux_insert_point,
   linux_remove_point,
+#ifndef __GENODE__
   linux_stopped_by_sw_breakpoint,
   linux_supports_stopped_by_sw_breakpoint,
   linux_stopped_by_hw_breakpoint,
@@ -7529,6 +7625,15 @@ static struct target_ops linux_target_ops = {
   linux_supports_hardware_single_step,
   linux_stopped_by_watchpoint,
   linux_stopped_data_address,
+#else
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+#endif
 #if defined(__UCLIBC__) && defined(HAS_NOMMU)	      \
     && defined(PT_TEXT_ADDR) && defined(PT_DATA_ADDR) \
     && defined(PT_TEXT_END_ADDR)
@@ -7541,6 +7646,7 @@ static struct target_ops linux_target_ops = {
 #else
   NULL,
 #endif
+#ifndef __GENODE__
   linux_qxfer_spu,
   hostio_last_error_from_errno,
   linux_qxfer_osdata,
@@ -7553,14 +7659,34 @@ static struct target_ops linux_target_ops = {
   linux_supports_vfork_events,
   linux_supports_exec_events,
   linux_handle_new_gdb_connection,
+#else
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+#endif
 #ifdef USE_THREAD_DB
   thread_db_handle_monitor_command,
 #else
   NULL,
 #endif
+#ifndef __GENODE__
   linux_common_core_of_thread,
   linux_read_loadmap,
+#else
+  NULL,
+  NULL,
+#endif
   linux_process_qsupported,
+#ifndef __GENODE__
   linux_supports_tracepoints,
   linux_read_pc,
   linux_write_pc,
@@ -7594,12 +7720,47 @@ static struct target_ops linux_target_ops = {
   linux_mntns_unlink,
   linux_mntns_readlink,
   linux_breakpoint_kind_from_pc,
+#else
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+#endif
   linux_sw_breakpoint_from_kind,
+#ifndef __GENODE__
   linux_proc_tid_get_name,
   linux_breakpoint_kind_from_current_state,
   linux_supports_software_single_step,
   linux_supports_catch_syscall,
   linux_get_ipa_tdesc_idx,
+#else
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL
+#endif
 };
 
 #ifdef HAVE_LINUX_REGSETS
@@ -7621,7 +7782,9 @@ initialize_low (void)
   memset (&sigchld_action, 0, sizeof (sigchld_action));
   set_target_ops (&linux_target_ops);
 
+#ifndef __GENODE__
   linux_ptrace_init_warnings ();
+#endif
 
   sigchld_action.sa_handler = sigchld_handler;
   sigemptyset (&sigchld_action.sa_mask);
diff --git a/gdb/gdbserver/linux-low.h b/gdb/gdbserver/linux-low.h
index 6eb7e30..f4e8f10 100644
--- a/gdb/gdbserver/linux-low.h
+++ b/gdb/gdbserver/linux-low.h
@@ -17,11 +17,16 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 #include "nat/linux-nat.h"
+#ifndef __GENODE__
 #include "nat/gdb_thread_db.h"
+#endif
 #include <signal.h>
 
 #include "gdbthread.h"
+
+#ifndef __GENODE__
 #include "gdb_proc_service.h"
+#endif
 
 /* Included for ptrace type definitions.  */
 #include "nat/linux-ptrace.h"
diff --git a/gdb/gdbserver/linux-x86-low.c b/gdb/gdbserver/linux-x86-low.c
index dd9538a..9b7420a 100644
--- a/gdb/gdbserver/linux-x86-low.c
+++ b/gdb/gdbserver/linux-x86-low.c
@@ -31,7 +31,9 @@
 #include "nat/amd64-linux-siginfo.h"
 #endif
 
+#ifndef __GENODE__
 #include "gdb_proc_service.h"
+#endif
 /* Don't include elf/common.h if linux/elf.h got included by
    gdb_proc_service.h.  */
 #ifndef ELFMAG0
@@ -52,11 +54,23 @@ static struct target_desc *tdesc_amd64_linux_no_xml;
 #endif
 static struct target_desc *tdesc_i386_linux_no_xml;
 
-
 static unsigned char jump_insn[] = { 0xe9, 0, 0, 0, 0 };
 static unsigned char small_jump_insn[] = { 0x66, 0xe9, 0, 0 };
 
 /* Backward compatibility for gdb without XML support.  */
+#ifdef __GENODE__
+
+static const char *xmltarget_i386_linux_no_xml = "@<target>\
+<architecture>i386</architecture>\
+</target>";
+
+#ifdef __x86_64__
+static const char *xmltarget_amd64_linux_no_xml = "@<target>\
+<architecture>i386:x86-64</architecture>\
+</target>";
+#endif
+
+#else
 
 static const char *xmltarget_i386_linux_no_xml = "@<target>\
 <architecture>i386</architecture>\
@@ -70,7 +84,17 @@ static const char *xmltarget_amd64_linux_no_xml = "@<target>\
 </target>";
 #endif
 
+#endif /* __GENODE__ */
+
+#ifdef __GENODE__
+#ifdef __x86_64__
+#include "amd64.h"
+#else
+#include "i386.h"
+#endif /* __x86_64__ */
+#else
 #include <sys/reg.h>
+#endif
 #include <sys/procfs.h>
 #include "nat/gdb_ptrace.h"
 #include <sys/uio.h>
@@ -119,7 +143,11 @@ static /*const*/ int i386_regmap[] =
 #define ORIG_EAX ORIG_RAX
 #define REGSIZE 8
 
-static const int x86_64_regmap[] =
+static
+#ifndef __GENODE__
+const
+#endif
+int x86_64_regmap[] =
 {
   RAX * 8, RBX * 8, RCX * 8, RDX * 8,
   RSI * 8, RDI * 8, RBP * 8, RSP * 8,
@@ -132,6 +160,7 @@ static const int x86_64_regmap[] =
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1,
   -1, -1, -1, -1, -1, -1, -1, -1,
+#ifndef __GENODE__
   ORIG_RAX * 8,
   -1, -1, -1, -1,			/* MPX registers BND0 ... BND3.  */
   -1, -1,				/* MPX registers BNDCFGU, BNDSTATUS.  */
@@ -144,6 +173,7 @@ static const int x86_64_regmap[] =
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1
+#endif
 };
 
 #define X86_64_NUM_REGS (sizeof (x86_64_regmap) / sizeof (x86_64_regmap[0]))
@@ -185,6 +215,7 @@ is_64bit_tdesc (void)
 
 /* Called by libthread_db.  */
 
+#ifndef __GENODE__
 ps_err_e
 ps_get_thread_area (struct ps_prochandle *ph,
 		    lwpid_t lwpid, int idx, void **base)
@@ -223,6 +254,7 @@ ps_get_thread_area (struct ps_prochandle *ph,
     return PS_OK;
   }
 }
+#endif
 
 /* Get the thread area address.  This is used to recognize which
    thread is which when tracing with the in-process agent library.  We
@@ -278,7 +310,11 @@ x86_cannot_store_register (int regno)
 {
 #ifdef __x86_64__
   if (is_64bit_tdesc ())
+#ifdef __GENODE__
+    return regno >= X86_64_NUM_REGS;
+#else
     return 0;
+#endif /* GENODE */
 #endif
 
   return regno >= I386_NUM_REGS;
@@ -289,12 +325,30 @@ x86_cannot_fetch_register (int regno)
 {
 #ifdef __x86_64__
   if (is_64bit_tdesc ())
+#ifdef __GENODE__
+    return regno >= X86_64_NUM_REGS;
+#else
     return 0;
+#endif /* GENODE */
 #endif
 
   return regno >= I386_NUM_REGS;
 }
 
+#ifdef __x86_64__
+static int
+x86_64_cannot_store_register (int regno)
+{
+  return regno >= X86_64_NUM_REGS;
+}
+
+static int
+x86_64_cannot_fetch_register (int regno)
+{
+  return regno >= X86_64_NUM_REGS;
+}
+#endif /* __x86_64__ */
+
 static void
 x86_fill_gregset (struct regcache *regcache, void *buf)
 {
@@ -317,8 +371,10 @@ x86_fill_gregset (struct regcache *regcache, void *buf)
   for (i = 0; i < I386_NUM_REGS; i++)
     collect_register (regcache, i, ((char *) buf) + i386_regmap[i]);
 
+#ifndef __GENODE__
   collect_register_by_name (regcache, "orig_eax",
 			    ((char *) buf) + ORIG_EAX * REGSIZE);
+#endif
 }
 
 static void
@@ -339,8 +395,10 @@ x86_store_gregset (struct regcache *regcache, const void *buf)
   for (i = 0; i < I386_NUM_REGS; i++)
     supply_register (regcache, i, ((char *) buf) + i386_regmap[i]);
 
+#ifndef __GENODE__
   supply_register_by_name (regcache, "orig_eax",
 			   ((char *) buf) + ORIG_EAX * REGSIZE);
+#endif
 }
 
 static void
@@ -460,7 +518,15 @@ x86_set_pc (struct regcache *regcache, CORE_ADDR pc)
     }
 }
 
+#ifdef __GENODE__
+/* The 'INT3' instruction is used by some kernel debuggers and thus cannot
+ * serve as breakpoint instruction for the GDB monitor. Instead, the 'HLT'
+ * instruction gets used. It's a privileged instruction which triggers an
+ * exception when executed in user mode */
+static const gdb_byte x86_breakpoint[] = { 0xF4 };
+#else
 static const gdb_byte x86_breakpoint[] = { 0xCC };
+#endif
 #define x86_breakpoint_len 1
 
 static int
@@ -469,7 +535,7 @@ x86_breakpoint_at (CORE_ADDR pc)
   unsigned char c;
 
   (*the_target->read_memory) (pc, &c, 1);
-  if (c == 0xCC)
+  if (c == x86_breakpoint[0])
     return 1;
 
   return 0;
@@ -628,6 +694,7 @@ x86_debug_reg_state (pid_t pid)
    as debugging it with a 32-bit GDBSERVER, we do the 32-bit <-> 64-bit
    conversion in-place ourselves.  */
 
+#ifndef __GENODE__
 /* Convert a ptrace/host siginfo object, into/from the siginfo in the
    layout of the inferiors' architecture.  Returns true if any
    conversion was done; false otherwise.  If DIRECTION is 1, then copy
@@ -654,6 +721,7 @@ x86_siginfo_fixup (siginfo_t *ptrace, gdb_byte *inf, int direction)
 
   return 0;
 }
+#endif
 
 static int use_xml;
 
@@ -694,6 +762,15 @@ int have_ptrace_getfpxregs =
 static const struct target_desc *
 x86_linux_read_description (void)
 {
+#ifdef __GENODE__
+#ifdef __x86_64__
+  extern struct target_desc *tdesc_amd64;
+  return tdesc_amd64;
+#else
+  extern struct target_desc *tdesc_i386;
+  return tdesc_i386;
+#endif
+#else
   unsigned int machine;
   int is_elf64;
   int xcr0_features;
@@ -856,7 +933,7 @@ x86_linux_read_description (void)
       else
 	return tdesc_i386_linux;
     }
-
+#endif /* __GENODE__ */
   gdb_assert_not_reached ("failed to return tdesc");
 }
 
@@ -951,13 +1028,24 @@ static struct regsets_info x86_regsets_info =
   };
 
 #ifdef __x86_64__
+static struct usrregs_info amd64_linux_usrregs_info =
+  {
+    X86_64_NUM_REGS,
+    x86_64_regmap,
+  };
+
 static struct regs_info amd64_linux_regs_info =
   {
     NULL, /* regset_bitmap */
+#ifdef __GENODE__
+    &amd64_linux_usrregs_info,
+#else
     NULL, /* usrregs_info */
+#endif
     &x86_regsets_info
   };
 #endif
+
 static struct usrregs_info i386_linux_usrregs_info =
   {
     I386_NUM_REGS,
@@ -2854,6 +2942,9 @@ x86_get_ipa_tdesc_idx (void)
   const struct target_desc *tdesc = regcache->tdesc;
 
 #ifdef __x86_64__
+#ifdef __GENODE__
+    return X86_TDESC_SSE;
+#else
   if (tdesc == tdesc_amd64_linux || tdesc == tdesc_amd64_linux_no_xml
       || tdesc == tdesc_x32_linux)
     return X86_TDESC_SSE;
@@ -2865,8 +2956,12 @@ x86_get_ipa_tdesc_idx (void)
     return X86_TDESC_AVX_MPX;
   if (tdesc == tdesc_amd64_avx512_linux || tdesc == tdesc_x32_avx512_linux)
     return X86_TDESC_AVX512;
+#endif /* __GENODE__ */
 #endif
 
+#ifdef __GENODE__
+    return X86_TDESC_SSE;
+#else
   if (tdesc == tdesc_i386_mmx_linux)
     return X86_TDESC_MMX;
   if (tdesc == tdesc_i386_linux || tdesc == tdesc_i386_linux_no_xml)
@@ -2879,7 +2974,7 @@ x86_get_ipa_tdesc_idx (void)
     return X86_TDESC_AVX_MPX;
   if (tdesc == tdesc_i386_avx512_linux)
     return X86_TDESC_AVX512;
-
+#endif /* __GENODE__ */
   return 0;
 }
 
@@ -2898,12 +2993,20 @@ struct linux_target_ops the_low_target =
   NULL, /* breakpoint_kind_from_pc */
   x86_sw_breakpoint_from_kind,
   NULL,
+#ifndef __GENODE__
   1,
+#else
+  0, /* With the HLT instruction, the PC does not get incremented */
+#endif
   x86_breakpoint_at,
   x86_supports_z_point_type,
   x86_insert_point,
   x86_remove_point,
+#ifndef __GENODE__
   x86_stopped_by_watchpoint,
+#else
+  NULL,
+#endif
   x86_stopped_data_address,
   /* collect_ptrace_register/supply_ptrace_register are not needed in the
      native i386 case (no registers smaller than an xfer unit), and are not
@@ -2911,11 +3014,20 @@ struct linux_target_ops the_low_target =
   NULL,
   NULL,
   /* need to fix up i386 siginfo if host is amd64 */
+#ifdef __GENODE__
+  NULL,
+#else
   x86_siginfo_fixup,
+#endif
   x86_linux_new_process,
   x86_linux_new_thread,
+#ifndef __GENODE__
   x86_linux_new_fork,
   x86_linux_prepare_to_resume,
+#else
+  NULL,
+  NULL,
+#endif
   x86_linux_process_qsupported,
   x86_supports_tracepoints,
   x86_get_thread_area,
@@ -2936,6 +3048,7 @@ initialize_low_arch (void)
 #ifdef __x86_64__
   init_registers_amd64_linux ();
   init_registers_amd64_avx_linux ();
+#ifndef __GENODE__
   init_registers_amd64_avx512_linux ();
   init_registers_amd64_mpx_linux ();
   init_registers_amd64_avx_mpx_linux ();
@@ -2947,17 +3060,24 @@ initialize_low_arch (void)
   tdesc_amd64_linux_no_xml = XNEW (struct target_desc);
   copy_target_description (tdesc_amd64_linux_no_xml, tdesc_amd64_linux);
   tdesc_amd64_linux_no_xml->xmltarget = xmltarget_amd64_linux_no_xml;
+#endif /* __GENODE__ */
 #endif
   init_registers_i386_linux ();
+#ifndef __GENODE__
   init_registers_i386_mmx_linux ();
+#endif
   init_registers_i386_avx_linux ();
+#ifndef __GENODE__
   init_registers_i386_avx512_linux ();
   init_registers_i386_mpx_linux ();
   init_registers_i386_avx_mpx_linux ();
+#endif
 
+#ifndef __GENODE__
   tdesc_i386_linux_no_xml = XNEW (struct target_desc);
   copy_target_description (tdesc_i386_linux_no_xml, tdesc_i386_linux);
   tdesc_i386_linux_no_xml->xmltarget = xmltarget_i386_linux_no_xml;
+#endif /* __GENODE__ */
 
   initialize_regsets_info (&x86_regsets_info);
 }
diff --git a/gdb/gdbserver/linux-x86-tdesc.h b/gdb/gdbserver/linux-x86-tdesc.h
index bcf0b95..79cb9fd 100644
--- a/gdb/gdbserver/linux-x86-tdesc.h
+++ b/gdb/gdbserver/linux-x86-tdesc.h
@@ -32,6 +32,15 @@ enum x86_linux_tdesc {
 };
 
 #ifdef __x86_64__
+#ifdef __GENODE__
+void init_registers_amd64 (void);
+static inline void init_registers_amd64_linux(void) { init_registers_amd64(); }
+extern const struct target_desc *tdesc_amd64_linux;
+
+void init_registers_amd64_avx (void);
+static inline void init_registers_amd64_avx_linux(void) { init_registers_amd64_avx(); }
+extern const struct target_desc *tdesc_amd64_avx_linux;
+#else
 
 #if defined __LP64__  || !defined IN_PROCESS_AGENT
 /* Defined in auto-generated file amd64-linux.c.  */
@@ -69,8 +78,20 @@ void init_registers_x32_avx512_linux (void);
 extern const struct target_desc *tdesc_x32_avx512_linux;
 #endif
 
+#endif /* __GENODE__ */
 #endif
 
+#ifdef __GENODE__
+/* Defined in auto-generated file i386.c.  */
+void init_registers_i386 (void);
+static inline void init_registers_i386_linux(void) { init_registers_i386(); }
+extern const struct target_desc *tdesc_i386_linux;
+
+void init_registers_i386_avx (void);
+static inline void init_registers_i386_avx_linux(void) { init_registers_i386_avx(); }
+extern const struct target_desc *tdesc_i386_avx_linux;
+#else
+
 #if defined __i386__ || !defined IN_PROCESS_AGENT
 /* Defined in auto-generated file i386-linux.c.  */
 void init_registers_i386_linux (void);
@@ -96,3 +117,4 @@ extern const struct target_desc *tdesc_i386_avx512_linux;
 void init_registers_i386_mpx_linux (void);
 extern const struct target_desc *tdesc_i386_mpx_linux;
 #endif
+#endif /* __GENODE__ */
diff --git a/gdb/gdbserver/remote-utils.c b/gdb/gdbserver/remote-utils.c
index caf32df..3d24f20 100644
--- a/gdb/gdbserver/remote-utils.c
+++ b/gdb/gdbserver/remote-utils.c
@@ -24,6 +24,12 @@
 #include "dll.h"
 #include "rsp-low.h"
 #include <ctype.h>
+
+#ifdef __GENODE__
+#include <sys/types.h>
+#include "genode-low.h"
+#endif
+
 #if HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
@@ -105,7 +111,10 @@ struct ui_file *gdb_stdlog;
 
 static int remote_is_stdio = 0;
 
-static gdb_fildes_t remote_desc = INVALID_DESCRIPTOR;
+#ifndef __GENODE__
+static
+#endif
+gdb_fildes_t remote_desc = INVALID_DESCRIPTOR;
 static gdb_fildes_t listen_desc = INVALID_DESCRIPTOR;
 
 /* FIXME headerize? */
diff --git a/gdb/gdbserver/server.c b/gdb/gdbserver/server.c
index 433af1f..2bb3be5 100644
--- a/gdb/gdbserver/server.c
+++ b/gdb/gdbserver/server.c
@@ -28,6 +28,12 @@
 #if HAVE_SIGNAL_H
 #include <signal.h>
 #endif
+
+#ifdef __GENODE__
+#include "genode-low.h"
+#include "linux-low.h"
+#endif
+
 #include "gdb_vecs.h"
 #include "gdb_wait.h"
 #include "btrace-common.h"
@@ -2979,11 +2985,11 @@ handle_v_requests (char *own_buf, int packet_len, int *new_packet_len)
 	  return;
 	}
     }
-
+#ifndef __GENODE__
   if (startswith (own_buf, "vFile:")
       && handle_vFile (own_buf, packet_len, new_packet_len))
     return;
-
+#endif
   if (startswith (own_buf, "vAttach;"))
     {
       if ((!extended_protocol || !multi_process) && target_running ())
@@ -3611,7 +3617,9 @@ captured_main (int argc, char *argv[])
      opened by remote_prepare.  */
   notice_open_fds ();
 
+#ifndef __GENODE__
   save_original_signals_state ();
+#endif /* __GENODE__ */
 
   /* We need to know whether the remote connection is stdio before
      starting the inferior.  Inferiors created in this scenario have
@@ -3801,7 +3809,11 @@ captured_main (int argc, char *argv[])
 /* Main function.  */
 
 int
+#ifdef __GENODE__
+gdbserver_main (int argc, char *argv[])
+#else
 main (int argc, char *argv[])
+#endif
 {
 
   TRY
@@ -3907,6 +3919,9 @@ process_serial_event (void)
   response_needed = 1;
 
   i = 0;
+#ifdef __GENODE
+  if (debug_threads) printf("GDB command = %s\n", own_buf);
+#endif
   ch = own_buf[i++];
   switch (ch)
     {
@@ -4003,7 +4018,9 @@ process_serial_event (void)
 		 need to hang around doing nothing, until the child is
 		 gone.  */
 	      join_inferior (pid);
+#ifndef __GENODE__
 	      exit (0);
+#endif
 	    }
 	}
       break;
@@ -4249,7 +4266,11 @@ process_serial_event (void)
 	  return 0;
 	}
       else
+#ifndef __GENODE__
 	exit (0);
+#else
+      return 0;
+#endif
 
     case 'T':
       {
@@ -4326,7 +4347,9 @@ process_serial_event (void)
       own_buf[0] = '\0';
       break;
     }
-
+#ifdef __GENODE__
+  if (debug_threads) printf("GDBserver response = %s\n", own_buf);
+#endif
   if (new_packet_len != -1)
     putpkt_binary (own_buf, new_packet_len);
   else
diff --git a/gdb/nat/gdb_ptrace.h b/gdb/nat/gdb_ptrace.h
index e889933..0be8fba 100644
--- a/gdb/nat/gdb_ptrace.h
+++ b/gdb/nat/gdb_ptrace.h
@@ -129,6 +129,7 @@
 extern PTRACE_TYPE_RET ptrace();
 #endif
 
+#ifndef __GENODE__
 /* Some systems, at least AIX and HP-UX have a ptrace with five
    arguments.  Since we never use the fifth argument, define a ptrace
    macro that calls the real ptrace with the last argument set to
@@ -149,5 +150,6 @@ extern PTRACE_TYPE_RET ptrace();
 # define ptrace(request, pid, addr, data) \
          ptrace ((PTRACE_TYPE_ARG1) request, pid, addr, data)
 #endif
+#endif /* __GENODE__ */
 
 #endif /* gdb_ptrace.h */
diff --git a/gdb/nat/linux-ptrace.c b/gdb/nat/linux-ptrace.c
index 3447e07..512313a 100644
--- a/gdb/nat/linux-ptrace.c
+++ b/gdb/nat/linux-ptrace.c
@@ -37,6 +37,7 @@ static int supported_ptrace_options = -1;
 void
 linux_ptrace_attach_fail_reason (pid_t pid, struct buffer *buffer)
 {
+#ifndef __GENODE__
   pid_t tracerpid;
 
   tracerpid = linux_proc_get_tracerpid_nowarn (pid);
@@ -49,6 +50,7 @@ linux_ptrace_attach_fail_reason (pid_t pid, struct buffer *buffer)
     buffer_xml_printf (buffer, _("process %d is a zombie "
 				 "- the process has already terminated"),
 		       (int) pid);
+#endif
 }
 
 /* See linux-ptrace.h.  */
@@ -82,12 +84,15 @@ linux_ptrace_attach_fail_reason_string (ptid_t ptid, int err)
 /* Address of the 'ret' instruction in asm code block below.  */
 EXTERN_C void linux_ptrace_test_ret_to_nx_instr (void);
 
+#ifndef __GENODE__
 #include <sys/reg.h>
+#endif
 #include <sys/mman.h>
 #include <signal.h>
 
 #endif /* defined __i386__ || defined __x86_64__ */
 
+#ifndef __GENODE__
 /* Test broken off-trunk Linux kernel patchset for NX support on i386.  It was
    removed in Fedora kernel 88fa1f0332d188795ed73d7ac2b1564e11a0b4cd.
 
@@ -249,6 +254,7 @@ linux_ptrace_test_ret_to_nx (void)
 	       "support detected!"));
 #endif /* defined __i386__ || defined __x86_64__ */
 }
+#endif /* __GENODE__ */
 
 /* Helper function to fork a process and make the child process call
    the function FUNCTION, passing CHILD_STACK as parameter.
@@ -334,6 +340,7 @@ static void linux_test_for_exitkill (int child_pid);
 void
 linux_check_ptrace_features (void)
 {
+#ifndef __GENODE__
   int child_pid, ret, status;
 
   /* Initialize the options.  */
@@ -371,6 +378,7 @@ linux_check_ptrace_features (void)
       my_waitpid (child_pid, &status, 0);
     }
   while (WIFSTOPPED (status));
+#endif
 }
 
 /* Determine if PTRACE_O_TRACESYSGOOD can be used to catch
@@ -488,6 +496,7 @@ linux_test_for_exitkill (int child_pid)
 void
 linux_enable_event_reporting (pid_t pid, int options)
 {
+#ifndef __GENODE__
   /* Check if we have initialized the ptrace features for this
      target.  If not, do it now.  */
   if (supported_ptrace_options == -1)
@@ -502,6 +511,7 @@ linux_enable_event_reporting (pid_t pid, int options)
   /* Set the options.  */
   ptrace (PTRACE_SETOPTIONS, pid, (PTRACE_TYPE_ARG3) 0,
 	  (PTRACE_TYPE_ARG4) (uintptr_t) options);
+#endif /* __GENODE__ */
 }
 
 /* Disable reporting of all currently supported ptrace events.  */
@@ -509,8 +519,10 @@ linux_enable_event_reporting (pid_t pid, int options)
 void
 linux_disable_event_reporting (pid_t pid)
 {
+#ifndef __GENODE__
   /* Set the options.  */
   ptrace (PTRACE_SETOPTIONS, pid, (PTRACE_TYPE_ARG3) 0, 0);
+#endif /* __GENODE__ */
 }
 
 /* Returns non-zero if PTRACE_OPTIONS is contained within
@@ -589,7 +601,9 @@ linux_ptrace_init_warnings (void)
     return;
   warned = 1;
 
+#ifndef __GENODE__
   linux_ptrace_test_ret_to_nx ();
+#endif
 }
 
 /* Extract extended ptrace event from wait status.  */
diff --git a/gdb/nat/linux-ptrace.h b/gdb/nat/linux-ptrace.h
index 5954945..5f9cc20 100644
--- a/gdb/nat/linux-ptrace.h
+++ b/gdb/nat/linux-ptrace.h
@@ -114,7 +114,11 @@ struct buffer;
    way to go.  That said, some architecture may get the si_code wrong,
    and as such we're leaving fallback code in place.  We'll remove
    this after a while if no problem is reported.  */
+#ifdef __GENODE__
+#define USE_SIGTRAP_SIGINFO 0
+#else
 #define USE_SIGTRAP_SIGINFO 1
+#endif
 
 /* The x86 kernel gets some of the si_code values backwards, like
    this:
