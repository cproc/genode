gdbserver_genode.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 gdb/gdbserver/linux-arm-low.c |   13 ++++
 gdb/gdbserver/linux-low.c     |  122 ++++++++++++++++++++++++++++++++++++++++-
 gdb/gdbserver/linux-low.h     |    3 +
 gdb/gdbserver/linux-x86-low.c |   54 ++++++++++++++++++
 gdb/gdbserver/remote-utils.c  |   11 +++-
 gdb/gdbserver/server.c        |   30 ++++++++--
 gdb/gdbserver/server.h        |    6 +-
 7 files changed, 228 insertions(+), 11 deletions(-)

diff --git a/gdb/gdbserver/linux-arm-low.c b/gdb/gdbserver/linux-arm-low.c
index 2718cec..1c42be7 100644
--- a/gdb/gdbserver/linux-arm-low.c
+++ b/gdb/gdbserver/linux-arm-low.c
@@ -24,6 +24,9 @@
 #ifndef ELFMAG0
 #include <elf.h>
 #endif
+#ifdef __GENODE__
+#include <sys/procfs.h>
+#endif
 #include <sys/ptrace.h>
 #include <signal.h>
 
@@ -268,7 +271,11 @@ static const unsigned short thumb2_breakpoint[] = { 0xf7f0, 0xa000 };
    is used for gdbserver, so single threaded debugging should work
    OK, but for multi-threaded debugging we only insert the current
    ABI's breakpoint instruction.  For now at least.  */
+#ifdef __GENODE__
+static const unsigned long arm_eabi_breakpoint = 0xe7ffdefe;
+#else
 static const unsigned long arm_eabi_breakpoint = 0xe7f001f0;
+#endif
 
 static int
 arm_breakpoint_at (CORE_ADDR where)
@@ -777,6 +784,11 @@ arm_arch_setup (void)
   arm_linux_init_hwbp_cap (pid);
 
   arm_hwcap = 0;
+
+#ifndef __GENODE__
+
+  /* Genode: 'init_registers_arm_with_*()' functions not generated */
+
   if (arm_get_hwcap (&arm_hwcap) == 0)
     {
       init_registers_arm ();
@@ -816,6 +828,7 @@ arm_arch_setup (void)
 
       return;
     }
+#endif
 
   /* The default configuration uses legacy FPA registers, probably
      simulated.  */
diff --git a/gdb/gdbserver/linux-low.c b/gdb/gdbserver/linux-low.c
index a476031..dbd624c 100644
--- a/gdb/gdbserver/linux-low.c
+++ b/gdb/gdbserver/linux-low.c
@@ -21,6 +21,10 @@
 #include "linux-osdata.h"
 #include "agent.h"
 
+#ifdef __GENODE__
+#include "genode-low.h"
+#endif
+
 #include <sys/wait.h>
 #include <stdio.h>
 #include <sys/param.h>
@@ -701,6 +705,7 @@ linux_attach_lwp_1 (unsigned long lwpid, int initial)
   ptid_t ptid;
   struct lwp_info *new_lwp;
 
+#ifndef __GENODE__
   if (ptrace (PTRACE_ATTACH, lwpid, 0, 0) != 0)
     {
       struct buffer buffer;
@@ -721,6 +726,7 @@ linux_attach_lwp_1 (unsigned long lwpid, int initial)
       error ("%sCannot attach to lwp %ld: %s (%d)", buffer_finish (&buffer),
 	     lwpid, strerror (errno), errno);
     }
+#endif
 
   if (initial)
     /* If lwp is the tgid, we handle adding existing threads later.
@@ -739,6 +745,9 @@ linux_attach_lwp_1 (unsigned long lwpid, int initial)
   new_lwp = (struct lwp_info *) add_lwp (ptid);
   add_thread (ptid, new_lwp);
 
+#ifdef __GENODE__
+  new_lwp->stopped = 1;
+#else
   /* We need to wait for SIGSTOP before being able to make the next
      ptrace call on this LWP.  */
   new_lwp->must_set_ptrace_flags = 1;
@@ -806,6 +815,7 @@ linux_attach_lwp_1 (unsigned long lwpid, int initial)
      end of the list, and so the new thread has not yet reached
      wait_for_sigstop (but will).  */
   new_lwp->stop_expected = 1;
+#endif
 }
 
 void
@@ -825,6 +835,7 @@ linux_attach (unsigned long pid)
   linux_attach_lwp_1 (pid, 1);
   linux_add_process (pid, 1);
 
+#ifndef __GENODE__
   if (!non_stop)
     {
       struct thread_info *thread;
@@ -893,7 +904,7 @@ Found and attached to new lwp %ld\n", lwp);
 	  closedir (dir);
 	}
     }
-
+#endif
   return 0;
 }
 
@@ -1139,7 +1150,11 @@ get_detach_signal (struct thread_info *thread)
     }
 }
 
+#ifdef __GENODE__
+int
+#else
 static int
+#endif
 linux_detach_one_lwp (struct inferior_list_entry *entry, void *args)
 {
   struct thread_info *thread = (struct thread_info *) entry;
@@ -1151,6 +1166,7 @@ linux_detach_one_lwp (struct inferior_list_entry *entry, void *args)
     return 0;
 
   /* If there is a pending SIGSTOP, get rid of it.  */
+#ifndef __GENODE__
   if (lwp->stop_expected)
     {
       if (debug_threads)
@@ -1161,11 +1177,13 @@ linux_detach_one_lwp (struct inferior_list_entry *entry, void *args)
       kill_lwp (lwpid_of (lwp), SIGCONT);
       lwp->stop_expected = 0;
     }
+#endif
 
   /* Flush any pending changes to the process's registers.  */
   regcache_invalidate_one ((struct inferior_list_entry *)
 			   get_lwp_thread (lwp));
 
+#ifndef __GENODE__
   /* Pass on any pending signal for this thread.  */
   sig = get_detach_signal (thread);
 
@@ -1177,6 +1195,7 @@ linux_detach_one_lwp (struct inferior_list_entry *entry, void *args)
     error (_("Can't detach %s: %s"),
 	   target_pid_to_str (ptid_of (lwp)),
 	   strerror (errno));
+#endif
 
   delete_lwp (lwp);
   return 0;
@@ -1403,6 +1422,10 @@ retry:
 
   if (WIFSTOPPED (*wstatp) && WSTOPSIG (*wstatp) == SIGTRAP)
     {
+#ifdef __GENODE__
+      /* no watchpoint support yet */
+	  child->stopped_by_watchpoint = 0;
+#else
       if (the_low_target.stopped_by_watchpoint == NULL)
 	{
 	  child->stopped_by_watchpoint = 0;
@@ -1428,7 +1451,8 @@ retry:
 
 	  current_inferior = saved_inferior;
 	}
-    }
+#endif
+	}
 
   /* Store the STOP_PC, with adjustment applied.  This depends on the
      architecture being defined already (so that CHILD has a valid
@@ -2796,18 +2820,22 @@ linux_wait (ptid_t ptid,
   if (debug_threads)
     fprintf (stderr, "linux_wait: [%s]\n", target_pid_to_str (ptid));
 
+#ifndef __GENODE__
   /* Flush the async file first.  */
   if (target_is_async_p ())
     async_file_flush ();
+#endif
 
   event_ptid = linux_wait_1 (ptid, ourstatus, target_options);
 
+#ifndef __GENODE__
   /* If at least one stop was reported, there may be more.  A single
      SIGCHLD can signal more than one child stop.  */
   if (target_is_async_p ()
       && (target_options & TARGET_WNOHANG) != 0
       && !ptid_equal (event_ptid, null_ptid))
     async_file_mark ();
+#endif
 
   return event_ptid;
 }
@@ -3290,10 +3318,25 @@ lwp %ld wants to get out of fast tracepoint jump pad single-stepping\n",
   lwp->stopped = 0;
   lwp->stopped_by_watchpoint = 0;
   lwp->stepping = step;
+
+#ifdef __GENODE__
+
+  /*
+   * On Linux, the thread would get stopped immediately after resuming
+   * if a SIGSTOP is pending. This is not the case on Genode, so we
+   * just keep the thread stopped.
+   */
+  if (lwp->stop_expected)
+	return;
+
+  genode_continue_thread(lwpid_of(lwp), step);
+
+#else
   ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, lwpid_of (lwp), 0,
 	  /* Coerce to a uintptr_t first to avoid potential gcc warning
 	     of coercing an 8 byte integer to a 4 byte pointer.  */
 	  (PTRACE_ARG4_TYPE) (uintptr_t) signal);
+#endif
 
   current_inferior = saved_inferior;
   if (errno)
@@ -5226,6 +5269,13 @@ linux_read_loadmap (const char *annex, CORE_ADDR offset,
 static void
 linux_process_qsupported (const char *query)
 {
+#ifdef __GENODE__
+  /*
+   * 'qSupported' is the first command sent by GDB when attaching to the
+   * server, so when at this location, GDB has just (re-)attached itself.
+   */
+  genode_stop_all_threads();
+#endif
   if (the_low_target.process_qsupported != NULL)
     the_low_target.process_qsupported (query);
 }
@@ -5335,6 +5385,7 @@ linux_get_min_fast_tracepoint_insn_len (void)
   return (*the_low_target.get_min_fast_tracepoint_insn_len) ();
 }
 
+#ifndef __GENODE__
 /* Extract &phdr and num_phdr in the inferior.  Return 0 on success.  */
 
 static int
@@ -5791,30 +5842,61 @@ linux_qxfer_libraries_svr4 (const char *annex, unsigned char *readbuf,
 
   return len;
 }
+#endif /* __GENODE__ */
 
 static struct target_ops linux_target_ops = {
   linux_create_inferior,
   linux_attach,
+#ifndef __GENODE__
   linux_kill,
   linux_detach,
   linux_mourn,
   linux_join,
+#else
+  genode_kill,
+  genode_detach,
+  NULL,
+  NULL,
+#endif
   linux_thread_alive,
   linux_resume,
   linux_wait,
+#ifndef __GENODE__
   linux_fetch_registers,
   linux_store_registers,
+#else
+  genode_fetch_registers,
+  genode_store_registers,
+#endif
   linux_prepare_to_access_memory,
   linux_done_accessing_memory,
+#ifndef __GENODE__
   linux_read_memory,
   linux_write_memory,
+#else
+  genode_read_memory,
+  genode_write_memory,
+#endif
+#ifndef __GENODE__
   linux_look_up_symbols,
+#else
+  NULL,
+#endif
   linux_request_interrupt,
+#ifndef __GENODE__
   linux_read_auxv,
+#else
+  NULL,
+#endif
   linux_insert_point,
   linux_remove_point,
+#ifndef __GENODE__
   linux_stopped_by_watchpoint,
   linux_stopped_data_address,
+#else
+  NULL,
+  NULL,
+#endif
 #if defined(__UCLIBC__) && defined(HAS_NOMMU)
   linux_read_offsets,
 #else
@@ -5825,6 +5907,7 @@ static struct target_ops linux_target_ops = {
 #else
   NULL,
 #endif
+#ifndef __GENODE__
   linux_qxfer_spu,
   hostio_last_error_from_errno,
   linux_qxfer_osdata,
@@ -5833,14 +5916,30 @@ static struct target_ops linux_target_ops = {
   linux_async,
   linux_start_non_stop,
   linux_supports_multi_process,
+#else
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+#endif
 #ifdef USE_THREAD_DB
   thread_db_handle_monitor_command,
 #else
   NULL,
 #endif
+#ifndef __GENODE__
   linux_common_core_of_thread,
   linux_read_loadmap,
+#else
+  NULL,
+  NULL,
+#endif
   linux_process_qsupported,
+#ifndef __GENODE__
   linux_supports_tracepoints,
   linux_read_pc,
   linux_write_pc,
@@ -5856,6 +5955,23 @@ static struct target_ops linux_target_ops = {
   linux_get_min_fast_tracepoint_insn_len,
   linux_qxfer_libraries_svr4,
   linux_supports_agent,
+#else
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL
+#endif
 };
 
 static void
@@ -5877,8 +5993,10 @@ initialize_low (void)
   set_breakpoint_data (the_low_target.breakpoint,
 		       the_low_target.breakpoint_len);
   linux_init_signals ();
+#ifndef __GENODE__
   linux_test_for_tracefork ();
   linux_ptrace_init_warnings ();
+#endif
 #ifdef HAVE_LINUX_REGSETS
   for (num_regsets = 0; target_regsets[num_regsets].size >= 0; num_regsets++)
     ;
diff --git a/gdb/gdbserver/linux-low.h b/gdb/gdbserver/linux-low.h
index 99d882a..adc6e8d 100644
--- a/gdb/gdbserver/linux-low.h
+++ b/gdb/gdbserver/linux-low.h
@@ -23,7 +23,10 @@
 #include <signal.h>
 
 #include "gdbthread.h"
+
+#ifndef __GENODE__
 #include "gdb_proc_service.h"
+#endif
 
 #define PTRACE_ARG3_TYPE void *
 #define PTRACE_ARG4_TYPE void *
diff --git a/gdb/gdbserver/linux-x86-low.c b/gdb/gdbserver/linux-x86-low.c
index 4ea284e..99ba002 100644
--- a/gdb/gdbserver/linux-x86-low.c
+++ b/gdb/gdbserver/linux-x86-low.c
@@ -28,9 +28,19 @@
 #include "i386-xstate.h"
 #include "elf/common.h"
 
+#ifndef __GENODE__
 #include "gdb_proc_service.h"
+#endif
+
 #include "agent.h"
 
+#ifdef __GENODE__
+/* Defined in auto-generated file i386.c.  */
+void init_registers_i386 (void);
+static inline void init_registers_i386_linux(void) { init_registers_i386(); }
+void init_registers_i386_avx (void);
+static inline void init_registers_i386_avx_linux(void) { init_registers_i386_avx(); }
+#else
 /* Defined in auto-generated file i386-linux.c.  */
 void init_registers_i386_linux (void);
 /* Defined in auto-generated file amd64-linux.c.  */
@@ -45,11 +55,25 @@ void init_registers_i386_mmx_linux (void);
 void init_registers_x32_linux (void);
 /* Defined in auto-generated file x32-avx-linux.c.  */
 void init_registers_x32_avx_linux (void);
+#endif
 
 static unsigned char jump_insn[] = { 0xe9, 0, 0, 0, 0 };
 static unsigned char small_jump_insn[] = { 0x66, 0xe9, 0, 0 };
 
 /* Backward compatibility for gdb without XML support.  */
+#ifdef __GENODE__
+
+static const char *xmltarget_i386_linux_no_xml = "@<target>\
+<architecture>i386</architecture>\
+</target>";
+
+#ifdef __x86_64__
+static const char *xmltarget_amd64_linux_no_xml = "@<target>\
+<architecture>i386:x86-64</architecture>\
+</target>";
+#endif
+
+#else
 
 static const char *xmltarget_i386_linux_no_xml = "@<target>\
 <architecture>i386</architecture>\
@@ -63,7 +87,15 @@ static const char *xmltarget_amd64_linux_no_xml = "@<target>\
 </target>";
 #endif
 
+#endif /* __GENODE__ */
+
+#ifdef __GENODE__
+#ifndef __x86_64__
+#include "i386.h"
+#endif /* __x86_64__ */
+#else
 #include <sys/reg.h>
+#endif
 #include <sys/procfs.h>
 #include <sys/ptrace.h>
 #include <sys/uio.h>
@@ -279,8 +311,10 @@ x86_fill_gregset (struct regcache *regcache, void *buf)
   for (i = 0; i < I386_NUM_REGS; i++)
     collect_register (regcache, i, ((char *) buf) + i386_regmap[i]);
 
+#ifndef __GENODE__
   collect_register_by_name (regcache, "orig_eax",
 			    ((char *) buf) + ORIG_EAX * 4);
+#endif
 }
 
 static void
@@ -301,8 +335,10 @@ x86_store_gregset (struct regcache *regcache, const void *buf)
   for (i = 0; i < I386_NUM_REGS; i++)
     supply_register (regcache, i, ((char *) buf) + i386_regmap[i]);
 
+#ifndef __GENODE__
   supply_register_by_name (regcache, "orig_eax",
 			   ((char *) buf) + ORIG_EAX * 4);
+#endif
 }
 
 static void
@@ -420,7 +456,15 @@ x86_set_pc (struct regcache *regcache, CORE_ADDR pc)
     }
 }
 
+#ifdef __GENODE__
+/* The 'INT3' instruction is used by some kernel debuggers and thus cannot
+ * serve as breakpoint instruction for the GDB monitor. Instead, the 'HLT'
+ * instruction gets used. It's a privileged instruction which triggers an
+ * exception when executed in user mode */
+static const unsigned char x86_breakpoint[] = { 0xF4 };
+#else
 static const unsigned char x86_breakpoint[] = { 0xCC };
+#endif
 #define x86_breakpoint_len 1
 
 static int
@@ -429,7 +473,7 @@ x86_breakpoint_at (CORE_ADDR pc)
   unsigned char c;
 
   (*the_target->read_memory) (pc, &c, 1);
-  if (c == 0xCC)
+  if (c == x86_breakpoint[0])
     return 1;
 
   return 0;
@@ -3189,7 +3233,11 @@ struct linux_target_ops the_low_target =
   x86_breakpoint,
   x86_breakpoint_len,
   NULL,
+#ifndef __GENODE__
   1,
+#else
+  0, /* With the HLT instruction, the PC does not get incremented */
+#endif
   x86_breakpoint_at,
   x86_insert_point,
   x86_remove_point,
@@ -3204,7 +3252,11 @@ struct linux_target_ops the_low_target =
   x86_siginfo_fixup,
   x86_linux_new_process,
   x86_linux_new_thread,
+#ifndef __GENODE__
   x86_linux_prepare_to_resume,
+#else
+  NULL,
+#endif
   x86_linux_process_qsupported,
   x86_supports_tracepoints,
   x86_get_thread_area,
diff --git a/gdb/gdbserver/remote-utils.c b/gdb/gdbserver/remote-utils.c
index 0b3adac..37c380a 100644
--- a/gdb/gdbserver/remote-utils.c
+++ b/gdb/gdbserver/remote-utils.c
@@ -20,6 +20,12 @@
 #include "terminal.h"
 #include "target.h"
 #include "gdbthread.h"
+
+#ifdef __GENODE__
+#include <sys/types.h>
+#include "genode-low.h"
+#endif
+
 #include <stdio.h>
 #include <string.h>
 #if HAVE_SYS_IOCTL_H
@@ -108,7 +114,10 @@ struct ui_file *gdb_stdlog;
 
 static int remote_is_stdio = 0;
 
-static gdb_fildes_t remote_desc = INVALID_DESCRIPTOR;
+#ifndef __GENODE__
+static
+#endif
+gdb_fildes_t remote_desc = INVALID_DESCRIPTOR;
 static gdb_fildes_t listen_desc = INVALID_DESCRIPTOR;
 
 /* FIXME headerize? */
diff --git a/gdb/gdbserver/server.c b/gdb/gdbserver/server.c
index 4e15b3c..dc0d5da 100644
--- a/gdb/gdbserver/server.c
+++ b/gdb/gdbserver/server.c
@@ -21,6 +21,11 @@
 #include "gdbthread.h"
 #include "agent.h"
 
+#ifdef __GENODE__
+#include "genode-low.h"
+#include "linux-low.h"
+#endif
+
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -2212,11 +2217,11 @@ handle_v_requests (char *own_buf, int packet_len, int *new_packet_len)
 	  return;
 	}
     }
-
+#ifndef __GENODE__
   if (strncmp (own_buf, "vFile:", 6) == 0
       && handle_vFile (own_buf, packet_len, new_packet_len))
     return;
-
+#endif
   if (strncmp (own_buf, "vAttach;", 8) == 0)
     {
       if ((!extended_protocol || !multi_process) && target_running ())
@@ -2597,7 +2602,11 @@ detach_or_kill_for_exit (void)
 }
 
 int
+#ifdef __GENODE__
+gdbserver_main (int argc, char *argv[])
+#else
 main (int argc, char *argv[])
+#endif
 {
   int bad_attach;
   int pid;
@@ -2989,6 +2998,9 @@ process_serial_event (void)
   response_needed = 1;
 
   i = 0;
+#ifdef __GENODE
+  if (debug_threads) printf("GDB command = %s\n", own_buf);
+#endif
   ch = own_buf[i++];
   switch (ch)
     {
@@ -3084,7 +3096,9 @@ process_serial_event (void)
 		 need to hang around doing nothing, until the child is
 		 gone.  */
 	      join_inferior (pid);
+#ifndef __GENODE__
 	      exit (0);
+#endif
 	    }
 	}
       break;
@@ -3329,7 +3343,11 @@ process_serial_event (void)
 	  return 0;
 	}
       else
+#ifndef __GENODE__
 	exit (0);
+#else
+      return 0;
+#endif
 
     case 'T':
       {
@@ -3393,14 +3411,16 @@ process_serial_event (void)
       own_buf[0] = '\0';
       break;
     }
-
+#ifdef __GENODE__
+  if (debug_threads) printf("GDBserver response = %s\n", own_buf);
+#endif
   if (new_packet_len != -1)
     putpkt_binary (own_buf, new_packet_len);
   else
     putpkt (own_buf);
 
   response_needed = 0;
-
+#ifndef __GENODE__
   if (!extended_protocol && have_ran && !target_running ())
     {
       /* In non-stop, defer exiting until GDB had a chance to query
@@ -3412,7 +3432,7 @@ process_serial_event (void)
 	  exit (0);
 	}
     }
-
+#endif
   if (exit_requested)
     return -1;
 
diff --git a/gdb/gdbserver/server.h b/gdb/gdbserver/server.h
index 40d05a5..0730458 100644
--- a/gdb/gdbserver/server.h
+++ b/gdb/gdbserver/server.h
@@ -21,7 +21,9 @@
 #define SERVER_H
 
 #include "config.h"
+#ifndef __GENODE__
 #include "build-gnulib-gdbserver/config.h"
+#endif
 
 #ifdef __MINGW32CE__
 #include "wincecompat.h"
@@ -552,8 +554,8 @@ CORE_ADDR get_get_tsv_func_addr (void);
    function in the IPA.  */
 CORE_ADDR get_set_tsv_func_addr (void);
 
-CORE_ADDR current_insn_ptr;
-int emit_error;
+extern CORE_ADDR current_insn_ptr;
+extern int emit_error;
 
 /* Version information, from version.c.  */
 extern const char version[];
