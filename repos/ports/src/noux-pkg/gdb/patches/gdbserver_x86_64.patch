gdbserver_x86_64.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 gdb/gdbserver/linux-x86-low.c |   61 ++++++++++++++++++++++++++++++++++++++---
 1 file changed, 57 insertions(+), 4 deletions(-)

diff --git a/gdb/gdbserver/linux-x86-low.c b/gdb/gdbserver/linux-x86-low.c
index e7994fe..d262b56 100644
--- a/gdb/gdbserver/linux-x86-low.c
+++ b/gdb/gdbserver/linux-x86-low.c
@@ -35,6 +35,12 @@
 #include "agent.h"
 
 #ifdef __GENODE__
+#ifdef __x86_64__
+void init_registers_amd64 (void);
+static inline void init_registers_amd64_linux(void) { init_registers_amd64(); }
+void init_registers_amd64_avx (void);
+static inline void init_registers_amd64_avx_linux(void) { init_registers_amd64_avx(); }
+#endif /* __x64_64__ */
 /* Defined in auto-generated file i386.c.  */
 void init_registers_i386 (void);
 static inline void init_registers_i386_linux(void) { init_registers_i386(); }
@@ -90,7 +96,9 @@ static const char *xmltarget_amd64_linux_no_xml = "@<target>\
 #endif /* __GENODE__ */
 
 #ifdef __GENODE__
-#ifndef __x86_64__
+#ifdef __x86_64__
+#include "amd64.h"
+#else
 #include "i386.h"
 #endif /* __x86_64__ */
 #else
@@ -160,7 +168,11 @@ static /*const*/ int i386_regmap[] =
 /* So code below doesn't have to care, i386 or amd64.  */
 #define ORIG_EAX ORIG_RAX
 
-static const int x86_64_regmap[] =
+static
+#ifndef __GENODE__
+const
+#endif
+int x86_64_regmap[] =
 {
   RAX * 8, RBX * 8, RCX * 8, RDX * 8,
   RSI * 8, RDI * 8, RBP * 8, RSP * 8,
@@ -172,7 +184,9 @@ static const int x86_64_regmap[] =
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1,
+#ifndef __GENODE__
   ORIG_RAX * 8
+#endif
 };
 
 #define X86_64_NUM_REGS (sizeof (x86_64_regmap) / sizeof (x86_64_regmap[0]))
@@ -195,6 +209,7 @@ static /*const*/ int i386_regmap[] =
 
 /* Called by libthread_db.  */
 
+#ifndef __GENODE__
 ps_err_e
 ps_get_thread_area (const struct ps_prochandle *ph,
 		    lwpid_t lwpid, int idx, void **base)
@@ -233,6 +248,7 @@ ps_get_thread_area (const struct ps_prochandle *ph,
     return PS_OK;
   }
 }
+#endif
 
 /* Get the thread area address.  This is used to recognize which
    thread is which when tracing with the in-process agent library.  We
@@ -294,6 +310,20 @@ i386_cannot_fetch_register (int regno)
   return regno >= I386_NUM_REGS;
 }
 
+#ifdef __x86_64__
+static int
+x86_64_cannot_store_register (int regno)
+{
+  return regno >= X86_64_NUM_REGS;
+}
+
+static int
+x86_64_cannot_fetch_register (int regno)
+{
+  return regno >= X86_64_NUM_REGS;
+}
+#endif /* __x86_64__ */
+
 static void
 x86_fill_gregset (struct regcache *regcache, void *buf)
 {
@@ -750,6 +780,7 @@ x86_linux_prepare_to_resume (struct lwp_info *lwp)
    support.  */
 
 #ifdef __x86_64__
+#ifndef __GENODE__
 
 typedef int compat_int_t;
 typedef unsigned int compat_uptr_t;
@@ -1135,11 +1166,12 @@ siginfo_from_compat_x32_siginfo (siginfo_t *to,
 	}
     }
 }
-
+#endif /* __GENODE__ */
 /* Is this process 64-bit?  */
 static int linux_is_elf64;
 #endif /* __x86_64__ */
 
+#ifndef __GENODE__
 /* Convert a native/host siginfo object, into/from the siginfo in the
    layout of the inferiors' architecture.  Returns true if any
    conversion was done; false otherwise.  If DIRECTION is 1, then copy
@@ -1182,6 +1214,7 @@ x86_siginfo_fixup (siginfo_t *native, void *inf, int direction)
 
   return 0;
 }
+#endif
 
 static int use_xml;
 
@@ -1354,6 +1387,10 @@ x86_linux_process_qsupported (const char *query)
 static void
 x86_arch_setup (void)
 {
+#ifdef __x86_64
+#ifdef __GENODE__
+  int is_elf64 = 1;
+#else
   int pid = pid_of (get_thread_lwp (current_inferior));
   unsigned int machine;
   int is_elf64 = linux_pid_exe_is_elf_64_file (pid, &machine);
@@ -1362,13 +1399,18 @@ x86_arch_setup (void)
     {
       if (is_elf64 > 0)
 	error (_("Can't debug 64-bit process with 32-bit GDBserver"));
+#ifndef __GENODE__
 #ifndef __x86_64__
       else if (machine == EM_X86_64)
 	error (_("Can't debug x86-64 process with 32-bit GDBserver"));
 #endif
+#endif
     }
+#endif
+#endif
 
 #ifdef __x86_64__
+#ifndef __GENODE__
   if (is_elf64 < 0)
     {
       /* This can only happen if /proc/<pid>/exe is unreadable,
@@ -1376,13 +1418,20 @@ x86_arch_setup (void)
 	 Fall through and assume this is a 32-bit program.  */
     }
   else if (machine == EM_X86_64)
+#endif
     {
+#ifdef __GENODE__
+      the_low_target.num_regs = X86_64_NUM_REGS;
+      the_low_target.regmap = x86_64_regmap;
+      the_low_target.cannot_fetch_register = x86_64_cannot_fetch_register;
+      the_low_target.cannot_store_register = x86_64_cannot_store_register;
+#else
       /* Amd64 doesn't have HAVE_LINUX_USRREGS.  */
       the_low_target.num_regs = -1;
       the_low_target.regmap = NULL;
       the_low_target.cannot_fetch_register = NULL;
       the_low_target.cannot_store_register = NULL;
-
+#endif
       /* Amd64 has 16 xmm regs.  */
       num_xmm_registers = 16;
 
@@ -3253,7 +3302,11 @@ struct linux_target_ops the_low_target =
   NULL,
   NULL,
   /* need to fix up i386 siginfo if host is amd64 */
+#ifdef __GENODE__
+  NULL,
+#else
   x86_siginfo_fixup,
+#endif
   x86_linux_new_process,
   x86_linux_new_thread,
 #ifndef __GENODE__
