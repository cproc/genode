gdbserver_genode2.diff

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 gdb/gdbserver/linux-low.c    |   81 +++++++++++++++++++++++++++++++++++-------
 gdb/gdbserver/linux-low.h    |    2 +
 gdb/gdbserver/remote-utils.c |   15 --------
 gdb/gdbserver/server.c       |   43 +++++++++++++++++-----
 4 files changed, 101 insertions(+), 40 deletions(-)

diff --git a/gdb/gdbserver/linux-low.c b/gdb/gdbserver/linux-low.c
index 330f859..3c08187 100644
--- a/gdb/gdbserver/linux-low.c
+++ b/gdb/gdbserver/linux-low.c
@@ -357,11 +357,14 @@ my_waitpid (int pid, int *status, int flags)
 	while(1) {
 
 		FD_ZERO (&readset);
-		FD_SET (remote_desc, &readset);
 
-		if (pid == -1)
+		if (remote_desc != -1)
+			FD_SET (remote_desc, &readset);
+
+		if (pid == -1) {
+			FD_SET(genode_new_thread_pipe_read_fd(), &readset);
 			find_inferior(&all_threads, add_signal_pipe_read_fd_to_set, &readset);
-		else
+		} else
 			FD_SET(genode_thread_signal_pipe_read_fd(pid), &readset);
 
 		struct timeval wnohang_timeout = {0, 0};
@@ -374,7 +377,7 @@ my_waitpid (int pid, int *status, int flags)
 			if (debug_threads)
 				fprintf(stderr, "select() returned\n");
 
-			if (FD_ISSET(remote_desc, &readset)) {
+			if ((remote_desc != -1) && FD_ISSET(remote_desc, &readset)) {
 
 				/* received input from GDB */
 
@@ -392,6 +395,33 @@ my_waitpid (int pid, int *status, int flags)
 					         cc, c, c);
 				}
 
+			} else if (FD_ISSET(genode_new_thread_pipe_read_fd(), &readset)) {
+
+				/* read the lwpid of the new thread from the pipe */
+				unsigned long new_lwpid;
+				read(genode_new_thread_pipe_read_fd(), &new_lwpid, sizeof(new_lwpid));
+				
+				/* make the new thread known to gdbserver */
+				{
+					ptid_t ptid = ptid_build (1, new_lwpid, 0);
+					struct lwp_info *new_lwp = (struct lwp_info *) add_lwp (ptid);
+					add_thread (ptid, new_lwp);
+				}
+
+				/* consume the SIGTRAP signal caused by initial single-stepping */
+				{
+					int signal;
+					read(genode_thread_signal_pipe_read_fd(new_lwpid), &signal, sizeof(signal));
+					fprintf(stderr, "new thread received signal %d\n", signal);
+					if (signal != SIGTRAP)
+						fprintf(stderr, "Error: first signal received by the new thread was not SIGTRAP\n");
+				}
+
+				/* resume the new thread */
+				genode_continue_thread(new_lwpid, 0);
+
+				continue;
+
 			} else {
 
 				/* received a signal */
@@ -532,10 +562,25 @@ handle_extended_wait (struct lwp_info *event_child, int wstat)
 	}
 #else
       int status = W_STOPCODE (SIGSTOP);
+
+#if 0
+      /* read the thread ID of the new thread from the signal pipe (payload) */
       read(genode_thread_signal_pipe_read_fd(lwpid_of(event_child)),
            &new_pid, sizeof(new_pid));
 #endif
 
+      //new_pid = genode_find_lwpid_of_new_thread();
+
+      /* consume the SIGTRAP signal caused by initial single-stepping */
+      {
+        int signal;
+        read(genode_thread_signal_pipe_read_fd(new_pid), &signal, sizeof(signal));
+        fprintf(stderr, "new thread received signal %d\n", signal);
+        if (signal != SIGTRAP)
+          fprintf(stderr, "Error: first signal received by the new thread was not SIGTRAP\n");
+      }
+#endif
+
       linux_enable_event_reporting (new_pid);
 
       ptid = ptid_build (pid_of (event_child), new_pid, 0);
@@ -670,10 +715,6 @@ add_lwp (ptid_t ptid)
 
   add_inferior_to_list (&all_lwps, &lwp->head);
 
-#ifdef __GENODE__
-  lwp->stopped = 1;
-#endif
-
   return lwp;
 }
 
@@ -766,7 +807,9 @@ linux_attach_lwp_1 (unsigned long lwpid, int initial)
   new_lwp = (struct lwp_info *) add_lwp (ptid);
   add_thread (ptid, new_lwp);
 
-#ifndef __GENODE__
+#ifdef __GENODE__
+  new_lwp->stopped = 1;
+#else
   /* We need to wait for SIGSTOP before being able to make the next
      ptrace call on this LWP.  */
   new_lwp->must_set_ptrace_flags = 1;
@@ -1764,6 +1807,7 @@ linux_wait_for_event_1 (ptid_t ptid, int *wstat, int options)
 	  && *wstat >> 16 != 0)
 #endif
 	{
+	  fprintf(stderr, "calling handle_extended_wait()\n");
 	  handle_extended_wait (event_child, *wstat);
 	  continue;
 	}
@@ -5285,6 +5329,13 @@ linux_core_of_thread (ptid_t ptid)
 static void
 linux_process_qsupported (const char *query)
 {
+#ifdef __GENODE__
+  /*
+   * 'qSupported' is the first command sent by GDB when attaching to the
+   * server, so when at this location, GDB has just (re-)attached itself.
+   */
+  genode_stop_all_threads();
+#endif
   if (the_low_target.process_qsupported != NULL)
     the_low_target.process_qsupported (query);
 }
@@ -5390,12 +5441,14 @@ static struct target_ops linux_target_ops = {
   NULL,
 #endif
   linux_attach,
-  genode_kill,
-  genode_detach,
 #ifndef __GENODE__
+  linux_kill,
+  linux_detach,
   linux_mourn,
   linux_join,
 #else
+  genode_kill,
+  genode_detach,
   NULL,
   NULL,
 #endif
@@ -5464,7 +5517,11 @@ static struct target_ops linux_target_ops = {
 #endif
 #ifndef __GENODE__
   linux_core_of_thread,
+#else
+  NULL,
+#endif
   linux_process_qsupported,
+#ifndef __GENODE__
   linux_supports_tracepoints,
   linux_read_pc,
   linux_write_pc,
@@ -5487,8 +5544,6 @@ static struct target_ops linux_target_ops = {
   NULL,
   NULL,
   NULL,
-  NULL,
-  NULL,
   NULL
 #endif
 };
diff --git a/gdb/gdbserver/linux-low.h b/gdb/gdbserver/linux-low.h
index fb4e4f7..704dc58 100644
--- a/gdb/gdbserver/linux-low.h
+++ b/gdb/gdbserver/linux-low.h
@@ -60,7 +60,7 @@ struct process_info_private
   struct thread_db *thread_db;
 
 #ifdef __GENODE__
-  void *gdb_stub_thread;
+  void *genode_child_resources;
 #endif
 };
 
diff --git a/gdb/gdbserver/remote-utils.c b/gdb/gdbserver/remote-utils.c
index 33db155..124bdda 100644
--- a/gdb/gdbserver/remote-utils.c
+++ b/gdb/gdbserver/remote-utils.c
@@ -193,14 +193,6 @@ handle_accept_event (int err, gdb_client_data client_data)
 
   enable_async_notification (remote_desc);
 
-#ifdef __GENODE__
-  /* stop all threads */
-  genode_stop_all_threads();
-
-  /* find all existing threads and tell gdbserver about it */
-  genode_detect_all_threads();
-#endif
-
   /* Register the event loop handler.  */
   add_file_handler (remote_desc, handle_serial_event, NULL);
 
@@ -296,13 +288,6 @@ remote_open (char *name)
       /* Register the event loop handler.  */
       add_file_handler (remote_desc, handle_serial_event, NULL);
 
-#ifdef __GENODE__
-      /* FIXME: find better place */
-      genode_stop_all_threads();
-      /* find all existing threads and tell gdbserver about it */
-      genode_detect_all_threads();
-#endif
-
 #endif /* USE_WIN32API */
     }
   else
diff --git a/gdb/gdbserver/server.c b/gdb/gdbserver/server.c
index bf0fc90..b7e43bc 100644
--- a/gdb/gdbserver/server.c
+++ b/gdb/gdbserver/server.c
@@ -2457,8 +2457,13 @@ join_inferiors_callback (struct inferior_list_entry *entry)
 }
 
 int
-gdbserver_main(char *port, void *gdb_stub_thread)
+#ifdef __GENODE__
+gdbserver_main(char *port)
+#else
+main (int argc, char *argv[])
+#endif
 {
+fprintf(stderr, "gdbserver_main()\n");
 #ifndef __GENODE__
   int bad_attach;
   int pid;
@@ -2594,7 +2599,7 @@ gdbserver_main(char *port, void *gdb_stub_thread)
       exit (1);
     }
 #endif
-
+fprintf(stderr, "calling initialize_inferiors()\n");
   initialize_inferiors ();
   initialize_async_io ();
   initialize_low ();
@@ -2661,8 +2666,33 @@ gdbserver_main(char *port, void *gdb_stub_thread)
 #endif
 
 #ifdef __GENODE__
+
+  void *genode_child_resources = genode_start_inferior();
+
+  if (!genode_child_resources)
+    return -1;
+
   /* wait until the target's main thread is ready */
   genode_wait_for_target_main_thread();
+
+fprintf(stderr, "main thread ready\n");
+
+  /* attach to child */
+  myattach(GENODE_LWP_BASE);
+  signal_pid = GENODE_LWP_BASE;
+  struct process_info *pi = current_process();
+  struct process_info_private *pip = pi->private;
+  pip->genode_child_resources = genode_child_resources;
+
+  /* consume the SIGTRAP signal caused by initial single-stepping */
+  {
+    int signal;
+    read(genode_thread_signal_pipe_read_fd(GENODE_LWP_BASE), &signal, sizeof(signal));
+    fprintf(stderr, "main thread received signal %d\n", signal);
+    if (signal != SIGTRAP)
+      fprintf(stderr, "Error: first signal received by the main thread was not SIGTRAP\n");
+  }
+
 #endif
 
   while (1)
@@ -2672,15 +2702,6 @@ gdbserver_main(char *port, void *gdb_stub_thread)
       /* Be sure we're out of tfind mode.  */
       current_traceframe = -1;
 
-#ifdef __GENODE__
-      /* attach to child */
-	  myattach(GENODE_LWP_BASE);
-	  signal_pid = GENODE_LWP_BASE;
-	  struct process_info *pi = current_process();
-	  struct process_info_private *pip = pi->private;
-	  pip->gdb_stub_thread = gdb_stub_thread;
-#endif
-
       remote_open (port);
 
       if (setjmp (toplevel) != 0)
