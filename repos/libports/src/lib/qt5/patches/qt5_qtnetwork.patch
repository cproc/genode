qt5_qtnetwork.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 qtbase/src/network/access/qhttpnetworkreply.cpp    |    8 ++++++++
 qtbase/src/network/socket/qnativesocketengine_p.h  |    4 ++++
 .../network/socket/qnativesocketengine_unix.cpp    |    2 ++
 qtbase/src/network/socket/qnet_unix_p.h            |   10 ++++++++++
 qtbase/src/network/ssl/qsslconfiguration_p.h       |    9 +++++++++
 qtbase/src/network/ssl/qsslsocket_openssl.cpp      |    3 +++
 6 files changed, 36 insertions(+)

diff --git a/qtbase/src/network/access/qhttpnetworkreply.cpp b/qtbase/src/network/access/qhttpnetworkreply.cpp
index 3601c36..00b1632 100644
--- a/qtbase/src/network/access/qhttpnetworkreply.cpp
+++ b/qtbase/src/network/access/qhttpnetworkreply.cpp
@@ -251,8 +251,16 @@ void QHttpNetworkReply::setReadBufferSize(qint64 size)
 
 bool QHttpNetworkReply::supportsUserProvidedDownloadBuffer()
 {
+#ifdef Q_OS_GENODE
+	/*
+	 * Without this change Arora shows garbage when loading, for example,
+	 * www.genode.org
+	 */
+	return false;
+#else
     Q_D(QHttpNetworkReply);
     return (!d->isChunked() && !d->autoDecompress && d->bodyLength > 0 && d->statusCode == 200);
+#endif
 }
 
 void QHttpNetworkReply::setUserProvidedDownloadBuffer(char* b)
diff --git a/qtbase/src/network/socket/qnativesocketengine_p.h b/qtbase/src/network/socket/qnativesocketengine_p.h
index 19e9e1d..b972ff0 100644
--- a/qtbase/src/network/socket/qnativesocketengine_p.h
+++ b/qtbase/src/network/socket/qnativesocketengine_p.h
@@ -286,8 +286,10 @@ public:
     bool checkProxy(const QHostAddress &address);
     bool fetchConnectionParameters();
 
+#ifndef QT_NO_NETWORKINTERFACE
     static uint scopeIdFromString(const QString &scopeid)
     { return QNetworkInterface::interfaceIndexFromName(scopeid); }
+#endif
 
     /*! \internal
         Sets \a address and \a port in the \a aa sockaddr structure and the size in \a sockAddrSize.
@@ -301,7 +303,9 @@ public:
             || socketProtocol == QAbstractSocket::AnyIPProtocol) {
             memset(&aa->a6, 0, sizeof(sockaddr_in6));
             aa->a6.sin6_family = AF_INET6;
+#ifndef QT_NO_NETWORKINTERFACE
             aa->a6.sin6_scope_id = scopeIdFromString(address.scopeId());
+#endif
             aa->a6.sin6_port = htons(port);
             Q_IPV6ADDR tmp = address.toIPv6Address();
             memcpy(&aa->a6.sin6_addr, &tmp, sizeof(tmp));
diff --git a/qtbase/src/network/socket/qnativesocketengine_unix.cpp b/qtbase/src/network/socket/qnativesocketengine_unix.cpp
index 7825be5..3270415 100644
--- a/qtbase/src/network/socket/qnativesocketengine_unix.cpp
+++ b/qtbase/src/network/socket/qnativesocketengine_unix.cpp
@@ -116,8 +116,10 @@ static inline void qt_socket_getPortAndAddress(const qt_sockaddr *s, quint16 *po
             QHostAddress tmpAddress;
             tmpAddress.setAddress(tmp);
             *addr = tmpAddress;
+#ifndef QT_NO_NETWORKINTERFACE
             if (s->a6.sin6_scope_id)
                 addr->setScopeId(QNetworkInterface::interfaceNameFromIndex(s->a6.sin6_scope_id));
+#endif
         }
         if (port)
             *port = ntohs(s->a6.sin6_port);
diff --git a/qtbase/src/network/socket/qnet_unix_p.h b/qtbase/src/network/socket/qnet_unix_p.h
index 8d2a4ae..c73f2db 100644
--- a/qtbase/src/network/socket/qnet_unix_p.h
+++ b/qtbase/src/network/socket/qnet_unix_p.h
@@ -185,6 +185,10 @@ static inline in_addr_t qt_safe_inet_addr(const char *cp)
 
 static inline int qt_safe_sendmsg(int sockfd, const struct msghdr *msg, int flags)
 {
+#ifdef Q_OS_GENODE
+    qWarning("qt_safe_sendmsg(): not implemented");
+    return -1;
+#else
 #ifdef MSG_NOSIGNAL
     flags |= MSG_NOSIGNAL;
 #else
@@ -194,14 +198,20 @@ static inline int qt_safe_sendmsg(int sockfd, const struct msghdr *msg, int flag
     int ret;
     EINTR_LOOP(ret, ::sendmsg(sockfd, msg, flags));
     return ret;
+#endif /* Q_OS_GENODE */
 }
 
 static inline int qt_safe_recvmsg(int sockfd, struct msghdr *msg, int flags)
 {
+#ifdef Q_OS_GENODE
+    qWarning("qt_safe_recvmsg(): not implemented");
+    return -1;
+#else
     int ret;
 
     EINTR_LOOP(ret, ::recvmsg(sockfd, msg, flags));
     return ret;
+#endif /* Q_OS_GENODE */
 }
 
 QT_END_NAMESPACE
diff --git a/qtbase/src/network/ssl/qsslconfiguration_p.h b/qtbase/src/network/ssl/qsslconfiguration_p.h
index 364bba9..b45a8cc 100644
--- a/qtbase/src/network/ssl/qsslconfiguration_p.h
+++ b/qtbase/src/network/ssl/qsslconfiguration_p.h
@@ -82,7 +82,16 @@ public:
     QSslConfigurationPrivate()
         : sessionProtocol(QSsl::UnknownProtocol),
           protocol(QSsl::SecureProtocols),
+#ifdef Q_OS_GENODE
+          /*
+           * With enabled peer verification, currently often a 'handshake error'
+           * occurs. This patch disables the peer verification until a fix for
+           * the handshake problem has been found.
+           */
+          peerVerifyMode(QSslSocket::VerifyNone),
+#else
           peerVerifyMode(QSslSocket::AutoVerifyPeer),
+#endif
           peerVerifyDepth(0),
           allowRootCertOnDemandLoading(true),
           peerSessionShared(false),
diff --git a/qtbase/src/network/ssl/qsslsocket_openssl.cpp b/qtbase/src/network/ssl/qsslsocket_openssl.cpp
index b3820ae..141f57b 100644
--- a/qtbase/src/network/ssl/qsslsocket_openssl.cpp
+++ b/qtbase/src/network/ssl/qsslsocket_openssl.cpp
@@ -491,7 +491,10 @@ bool QSslSocketPrivate::ensureLibraryLoaded()
         if (q_SSL_library_init() != 1)
             return false;
         q_SSL_load_error_strings();
+#ifndef Q_OS_GENODE
+        /* FIXME: currently, on Genode this function causes 'exit(1)' */
         q_OpenSSL_add_all_algorithms();
+#endif
 
 #if OPENSSL_VERSION_NUMBER >= 0x10001000L
         if (q_SSLeay() >= 0x10001000L)
