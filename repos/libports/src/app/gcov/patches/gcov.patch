gcov.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 gcc/gcov.c |   78 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 76 insertions(+), 2 deletions(-)

diff --git a/gcc/gcov.c b/gcc/gcov.c
index 50061c7..603be84 100644
--- a/gcc/gcov.c
+++ b/gcc/gcov.c
@@ -41,10 +41,13 @@ along with Gcov; see the file COPYING3.  If not see
 
 #include <getopt.h>
 
+#include <dirent.h>
+
 #define IN_GCOV 1
 #include "gcov-io.h"
 #include "gcov-io.c"
 
+
 /* The gcno file is generated by -ftest-coverage option. The gcda file is
    generated by a program compiled with -fprofile-arcs. Their formats
    are documented in gcov-io.h.  */
@@ -407,6 +410,57 @@ static void release_structures (void);
 static void release_function (function_t *);
 extern int main (int, char **);
 
+void process_files(const char *dir_path)
+{
+	printf("process_files(): %p\n", &dir_path);
+
+	char new_path[strlen(dir_path) + sizeof('/') + NAME_MAX];
+
+	DIR *dir = opendir(dir_path);
+
+	if (!dir) {
+		printf("opendir() failed\n");
+		return;
+	}
+
+	struct dirent *dirent;
+
+	while((dirent = readdir(dir)) != NULL) {
+
+		printf("found dir entry: %s\n", dirent->d_name);
+
+		snprintf(new_path, sizeof(new_path), "%s/%s", dir_path, dirent->d_name);
+
+		struct stat stat_buf;
+
+		if (stat(new_path, &stat_buf) != 0) {
+			printf("stat() failed\n");
+			continue;
+		}
+
+		if (S_ISDIR(stat_buf.st_mode)) {
+			printf("found dir\n");
+			process_files(new_path);
+			continue;
+		}
+		
+		if (!S_ISREG(stat_buf.st_mode)) {
+			printf("no regular file\n");
+			continue;
+		}
+		
+		if (!strstr(dirent->d_name, ".gcda")) {
+			printf("no .gcda file\n");
+			continue;
+		}
+
+		printf("processing file: %s\n", new_path);
+		process_file(new_path);
+	}
+
+  	closedir(dir);
+}
+
 int
 main (int argc, char **argv)
 {
@@ -445,6 +499,17 @@ main (int argc, char **argv)
 
   first_arg = argno;
   
+  if (strcmp(argv[first_arg], "*") == 0) {
+
+  	fprintf(stderr, "*** wildcard detected\n");
+
+  	/* search .gcda files and process each one */
+  	process_files("/");
+
+	/* finish processing arguments */
+	argno = argc;
+  }
+
   for (; argno != argc; argno++)
     {
       if (flag_display_progress)
@@ -788,14 +853,15 @@ output_gcov_file (const char *file_name, source_t *src)
 
   if (src->coverage.lines)
     {
-      FILE *gcov_file = fopen (gcov_file_name, "w");
+      //FILE *gcov_file = fopen (gcov_file_name, "w");
+      FILE *gcov_file = stdout;
       if (gcov_file)
         {
           fnotice (stdout, "Creating '%s'\n", gcov_file_name);
           output_lines (gcov_file, src);
           if (ferror (gcov_file))
             fnotice (stderr, "Error writing output file '%s'\n", gcov_file_name);
-          fclose (gcov_file);
+          //fclose (gcov_file);
         }
       else
         fnotice (stderr, "Could not open output file '%s'\n", gcov_file_name);
@@ -1114,6 +1180,14 @@ find_source (const char *file_name)
 #endif
 	  && IS_DIR_SEPARATOR (src->coverage.name[source_length]))
 	src->coverage.name += source_length + 1;
+
+      /* strip path of the Genode depot */
+      char *depot_relative_path = strstr(src->name, "/depot/");
+      if (depot_relative_path) {
+        src->name = depot_relative_path + strlen("/depot");
+        src->coverage.name = src->name;
+      }
+
       if (!stat (src->name, &status))
 	src->file_time = status.st_mtime;
     }
