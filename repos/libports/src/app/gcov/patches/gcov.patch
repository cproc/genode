gcov.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 gcc/gcov.c |   89 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 84 insertions(+), 5 deletions(-)

diff --git a/gcc/gcov.c b/gcc/gcov.c
index 50061c7..eead285 100644
--- a/gcc/gcov.c
+++ b/gcc/gcov.c
@@ -41,10 +41,13 @@ along with Gcov; see the file COPYING3.  If not see
 
 #include <getopt.h>
 
+#include <dirent.h>
+
 #define IN_GCOV 1
 #include "gcov-io.h"
 #include "gcov-io.c"
 
+
 /* The gcno file is generated by -ftest-coverage option. The gcda file is
    generated by a program compiled with -fprofile-arcs. Their formats
    are documented in gcov-io.h.  */
@@ -350,6 +353,16 @@ static int flag_all_blocks = 0;
 
 static int flag_function_summary = 0;
 
+/*
+ * Genode autopilot mode
+ *
+ * - scans for gcov data files
+ * - strips the Genode depot path from source paths
+ * - writes results to stdout
+ */
+
+static int flag_genode_autopilot = 0;
+
 /* Object directory file prefix.  This is the directory/file where the
    graph and data files are looked for, if nonzero.  */
 
@@ -407,6 +420,43 @@ static void release_structures (void);
 static void release_function (function_t *);
 extern int main (int, char **);
 
+void process_files(const char *dir_path)
+{
+	char new_path[strlen(dir_path) + sizeof('/') + NAME_MAX];
+
+	DIR *dir = opendir(dir_path);
+
+	if (!dir)
+		return;
+
+	struct dirent *dirent;
+
+	while((dirent = readdir(dir)) != NULL) {
+
+		snprintf(new_path, sizeof(new_path), "%s/%s", dir_path, dirent->d_name);
+
+		struct stat stat_buf;
+
+		if (stat(new_path, &stat_buf) != 0)
+			continue;
+
+		if (S_ISDIR(stat_buf.st_mode)) {
+			process_files(new_path);
+			continue;
+		}
+		
+		if (!S_ISREG(stat_buf.st_mode))
+			continue;
+		
+		if (!strstr(dirent->d_name, ".gcda"))
+			continue;
+
+		process_file(new_path);
+	}
+
+  	closedir(dir);
+}
+
 int
 main (int argc, char **argv)
 {
@@ -437,7 +487,7 @@ main (int argc, char **argv)
   sources = XNEWVEC (source_t, a_sources);
   
   argno = process_args (argc, argv);
-  if (optind == argc)
+  if ((optind == argc) && !flag_genode_autopilot)
     print_usage (true);
 
   if (argc - argno > 1)
@@ -445,6 +495,15 @@ main (int argc, char **argv)
 
   first_arg = argno;
   
+  if (flag_genode_autopilot) {
+
+  	/* search .gcda files and process each one */
+  	process_files("/");
+
+	/* finish processing arguments */
+	argno = argc;
+  }
+
   for (; argno != argc; argno++)
     {
       if (flag_display_progress)
@@ -488,7 +547,8 @@ print_usage (int error_p)
   fnotice (file, "  -r, --relative-only             Only show data for relative sources\n");
   fnotice (file, "  -s, --source-prefix DIR         Source prefix to elide\n");
   fnotice (file, "  -u, --unconditional-branches    Show unconditional branch counts too\n");
-  fnotice (file, "  -v, --version                   Print version number, then exit\n");
+  fnotice (file, "  -v, --version                   Print version number, then exit\n\n");
+  fnotice (file, "  -g, --genode-autopilot          Genode autopilot mode\n");
   fnotice (file, "\nFor bug reporting instructions, please see:\n%s.\n",
 	   bug_report_url);
   exit (status);
@@ -528,6 +588,7 @@ static const struct option options[] =
   { "source-prefix",        required_argument, NULL, 's' },
   { "unconditional-branches", no_argument,     NULL, 'u' },
   { "display-progress",     no_argument,       NULL, 'd' },
+  { "genode-autopilot",     no_argument,       NULL, 'g' },
   { 0, 0, 0, 0 }
 };
 
@@ -538,7 +599,7 @@ process_args (int argc, char **argv)
 {
   int opt;
 
-  while ((opt = getopt_long (argc, argv, "abcdfhilmno:s:pruv", options, NULL)) !=
+  while ((opt = getopt_long (argc, argv, "abcdfghilmno:s:pruv", options, NULL)) !=
          -1)
     {
       switch (opt)
@@ -555,6 +616,9 @@ process_args (int argc, char **argv)
 	case 'f':
 	  flag_function_summary = 1;
 	  break;
+	case 'g':
+	  flag_genode_autopilot = 1;
+	  break;
 	case 'h':
 	  print_usage (false);
 	  /* print_usage will exit.  */
@@ -788,14 +852,17 @@ output_gcov_file (const char *file_name, source_t *src)
 
   if (src->coverage.lines)
     {
-      FILE *gcov_file = fopen (gcov_file_name, "w");
+      FILE *gcov_file = flag_genode_autopilot ?
+                        stdout :
+                        fopen (gcov_file_name, "w");
       if (gcov_file)
         {
           fnotice (stdout, "Creating '%s'\n", gcov_file_name);
           output_lines (gcov_file, src);
           if (ferror (gcov_file))
             fnotice (stderr, "Error writing output file '%s'\n", gcov_file_name);
-          fclose (gcov_file);
+          if (!flag_genode_autopilot)
+            fclose (gcov_file);
         }
       else
         fnotice (stderr, "Could not open output file '%s'\n", gcov_file_name);
@@ -1114,6 +1181,18 @@ find_source (const char *file_name)
 #endif
 	  && IS_DIR_SEPARATOR (src->coverage.name[source_length]))
 	src->coverage.name += source_length + 1;
+
+      if (flag_genode_autopilot) {
+
+        /* strip path of the Genode depot */
+
+        char *depot_relative_path = strstr(src->name, "/depot/");
+        if (depot_relative_path) {
+          src->name = depot_relative_path + strlen("/depot");
+          src->coverage.name = src->name;
+        }
+      }
+
       if (!stat (src->name, &status))
 	src->file_time = status.st_mtime;
     }
