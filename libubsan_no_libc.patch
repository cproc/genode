libubsan_no_libc.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 libsanitizer/sanitizer_common/sanitizer_platform.h |    4 
 libsanitizer/sanitizer_common/sanitizer_posix.cc   |   44 ++--
 .../sanitizer_common/sanitizer_posix_libcdep.cc    |  205 ++++----------------
 libsanitizer/sanitizer_common/sanitizer_printf.cc  |    2 
 .../sanitizer_symbolizer_posix_libcdep.cc          |  130 +------------
 libsanitizer/ubsan/ubsan_diag.cc                   |    4 
 6 files changed, 75 insertions(+), 314 deletions(-)

diff --git a/libsanitizer/sanitizer_common/sanitizer_platform.h b/libsanitizer/sanitizer_common/sanitizer_platform.h
index 7d0ff28..e096ee9 100644
--- a/libsanitizer/sanitizer_common/sanitizer_platform.h
+++ b/libsanitizer/sanitizer_common/sanitizer_platform.h
@@ -11,10 +11,12 @@
 #ifndef SANITIZER_PLATFORM_H
 #define SANITIZER_PLATFORM_H
 
+#if 0
 #if !defined(__linux__) && !defined(__FreeBSD__) && \
   !defined(__APPLE__) && !defined(_WIN32)
 # error "This operating system is not supported"
 #endif
+#endif
 
 #if defined(__linux__)
 # define SANITIZER_LINUX   1
@@ -59,7 +61,7 @@
 # define SANITIZER_ANDROID 0
 #endif
 
-#define SANITIZER_POSIX (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC)
+#define SANITIZER_POSIX (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || 1)
 
 #if __LP64__ || defined(_WIN64)
 #  define SANITIZER_WORDSIZE 64
diff --git a/libsanitizer/sanitizer_common/sanitizer_posix.cc b/libsanitizer/sanitizer_common/sanitizer_posix.cc
index 49b40c8..8847c84 100644
--- a/libsanitizer/sanitizer_common/sanitizer_posix.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_posix.cc
@@ -22,9 +22,11 @@
 #include "sanitizer_procmaps.h"
 #include "sanitizer_stacktrace.h"
 
+#if 0
 #include <fcntl.h>
 #include <signal.h>
 #include <sys/mman.h>
+#endif
 
 #if SANITIZER_LINUX
 #include <sys/utsname.h>
@@ -115,8 +117,8 @@ uptr GetMaxVirtualAddress() {
 void *MmapOrDie(uptr size, const char *mem_type) {
   size = RoundUpTo(size, GetPageSizeCached());
   uptr res = internal_mmap(nullptr, size,
-                           PROT_READ | PROT_WRITE,
-                           MAP_PRIVATE | MAP_ANON, -1, 0);
+                           0/*PROT_READ | PROT_WRITE*/,
+                           0/*MAP_PRIVATE | MAP_ANON*/, -1, 0);
   int reserrno;
   if (internal_iserror(res, &reserrno))
     ReportMmapFailureAndDie(size, mem_type, "allocate", reserrno);
@@ -139,8 +141,8 @@ void *MmapNoReserveOrDie(uptr size, const char *mem_type) {
   uptr PageSize = GetPageSizeCached();
   uptr p = internal_mmap(nullptr,
                          RoundUpTo(size, PageSize),
-                         PROT_READ | PROT_WRITE,
-                         MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,
+                         0/*PROT_READ | PROT_WRITE*/,
+                         0/*MAP_PRIVATE | MAP_ANON | MAP_NORESERVE*/,
                          -1, 0);
   int reserrno;
   if (internal_iserror(p, &reserrno))
@@ -153,8 +155,8 @@ void *MmapFixedOrDie(uptr fixed_addr, uptr size) {
   uptr PageSize = GetPageSizeCached();
   uptr p = internal_mmap((void*)(fixed_addr & ~(PageSize - 1)),
       RoundUpTo(size, PageSize),
-      PROT_READ | PROT_WRITE,
-      MAP_PRIVATE | MAP_ANON | MAP_FIXED,
+      0/*PROT_READ | PROT_WRITE*/,
+      0/*MAP_PRIVATE | MAP_ANON | MAP_FIXED*/,
       -1, 0);
   int reserrno;
   if (internal_iserror(p, &reserrno)) {
@@ -168,16 +170,19 @@ void *MmapFixedOrDie(uptr fixed_addr, uptr size) {
 }
 
 bool MprotectNoAccess(uptr addr, uptr size) {
-  return 0 == internal_mprotect((void*)addr, size, PROT_NONE);
+Genode::log("sanitizer: ", __func__, " called");
+  return false;
 }
 
 fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *errno_p) {
   int flags;
+#if 0
   switch (mode) {
     case RdOnly: flags = O_RDONLY; break;
     case WrOnly: flags = O_WRONLY | O_CREAT; break;
     case RdWr: flags = O_RDWR | O_CREAT; break;
   }
+#endif
   fd_t res = internal_open(filename, flags, 0660);
   if (internal_iserror(res, errno_p))
     return kInvalidFd;
@@ -214,27 +219,13 @@ bool RenameFile(const char *oldpath, const char *newpath, error_t *error_p) {
 }
 
 void *MapFileToMemory(const char *file_name, uptr *buff_size) {
-  fd_t fd = OpenFile(file_name, RdOnly);
-  CHECK(fd != kInvalidFd);
-  uptr fsize = internal_filesize(fd);
-  CHECK_NE(fsize, (uptr)-1);
-  CHECK_GT(fsize, 0);
-  *buff_size = RoundUpTo(fsize, GetPageSizeCached());
-  uptr map = internal_mmap(nullptr, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);
-  return internal_iserror(map) ? nullptr : (void *)map;
+Genode::error("sanitizer: ", __func__, ", called");
+  return nullptr;
 }
 
 void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset) {
-  uptr flags = MAP_SHARED;
-  if (addr) flags |= MAP_FIXED;
-  uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);
-  int mmap_errno = 0;
-  if (internal_iserror(p, &mmap_errno)) {
-    Printf("could not map writable file (%d, %lld, %zu): %zd, errno: %d\n",
-           fd, (long long)offset, size, p, mmap_errno);
-    return nullptr;
-  }
-  return (void *)p;
+	Genode::error("sanitizer: ", __func__, ", called");
+	return nullptr;
 }
 
 static inline bool IntervalsAreSeparate(uptr start1, uptr end1,
@@ -305,7 +296,8 @@ bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {
 }
 
 SignalContext SignalContext::Create(void *siginfo, void *context) {
-  uptr addr = (uptr)((siginfo_t*)siginfo)->si_addr;
+	Genode::error("sanitizer: ", __func__, " called");
+  uptr addr = 0;
   uptr pc, sp, bp;
   GetPcSpBp(context, &pc, &sp, &bp);
   return SignalContext(context, addr, pc, sp, bp);
diff --git a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc
index 4b7273b..14090e2 100644
--- a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc
@@ -10,18 +10,23 @@
 // from sanitizer_libc.h.
 //===----------------------------------------------------------------------===//
 
+#include <base/log.h>
+
 #include "sanitizer_platform.h"
 
 #if SANITIZER_POSIX
 
 #include "sanitizer_common.h"
 #include "sanitizer_flags.h"
+#if 0
 #include "sanitizer_platform_limits_posix.h"
+#endif
 #include "sanitizer_posix.h"
 #include "sanitizer_procmaps.h"
 #include "sanitizer_stacktrace.h"
 #include "sanitizer_symbolizer.h"
 
+#if 0
 #include <errno.h>
 #include <fcntl.h>
 #include <pthread.h>
@@ -33,6 +38,9 @@
 #include <sys/time.h>
 #include <sys/types.h>
 #include <unistd.h>
+#endif
+
+#include <stddef.h>
 
 #if SANITIZER_FREEBSD
 // The MAP_NORESERVE define has been removed in FreeBSD 11.x, and even before
@@ -44,15 +52,17 @@
 namespace __sanitizer {
 
 u32 GetUid() {
-  return getuid();
+	Genode::error("sanitizer: ", __func__, " called");
+  return 0;
 }
 
 uptr GetThreadSelf() {
-  return (uptr)pthread_self();
+	Genode::error("sanitizer: ", __func__, " called");
+  return 0;
 }
 
 void FlushUnneededShadowMemory(uptr addr, uptr size) {
-  madvise((void*)addr, size, MADV_DONTNEED);
+	Genode::error("sanitizer: ", __func__, " called");
 }
 
 void NoHugePagesInRegion(uptr addr, uptr size) {
@@ -67,150 +77,68 @@ void DontDumpShadowMemory(uptr addr, uptr length) {
 #endif
 }
 
-static rlim_t getlim(int res) {
-  rlimit rlim;
-  CHECK_EQ(0, getrlimit(res, &rlim));
-  return rlim.rlim_cur;
-}
-
-static void setlim(int res, rlim_t lim) {
-  // The following magic is to prevent clang from replacing it with memset.
-  volatile struct rlimit rlim;
-  rlim.rlim_cur = lim;
-  rlim.rlim_max = lim;
-  if (setrlimit(res, const_cast<struct rlimit *>(&rlim))) {
-    Report("ERROR: %s setrlimit() failed %d\n", SanitizerToolName, errno);
-    Die();
-  }
-}
-
 void DisableCoreDumperIfNecessary() {
-  if (common_flags()->disable_coredump) {
-    setlim(RLIMIT_CORE, 0);
-  }
+	Genode::error("sanitizer: ", __func__, " called");
 }
 
 bool StackSizeIsUnlimited() {
-  rlim_t stack_size = getlim(RLIMIT_STACK);
-  return (stack_size == RLIM_INFINITY);
+	Genode::error("sanitizer: ", __func__, " called");
+	return true;
 }
 
 void SetStackSizeLimitInBytes(uptr limit) {
-  setlim(RLIMIT_STACK, (rlim_t)limit);
-  CHECK(!StackSizeIsUnlimited());
+	Genode::error("sanitizer: ", __func__, " called");
 }
 
 bool AddressSpaceIsUnlimited() {
-  rlim_t as_size = getlim(RLIMIT_AS);
-  return (as_size == RLIM_INFINITY);
+	Genode::error("sanitizer: ", __func__, " called");
+  return true;
 }
 
 void SetAddressSpaceUnlimited() {
-  setlim(RLIMIT_AS, RLIM_INFINITY);
-  CHECK(AddressSpaceIsUnlimited());
+	Genode::error("sanitizer: ", __func__, " called");
 }
 
 void SleepForSeconds(int seconds) {
-  sleep(seconds);
+	Genode::error("sanitizer: ", __func__, " called");
 }
 
 void SleepForMillis(int millis) {
-  usleep(millis * 1000);
+	Genode::error("sanitizer: ", __func__, " called");
 }
 
 void Abort() {
-  abort();
+	Genode::error("sanitizer: ", __func__, " called");
 }
 
 int Atexit(void (*function)(void)) {
-#ifndef SANITIZER_GO
-  return atexit(function);
-#else
+	Genode::error("sanitizer: ", __func__, " called");
   return 0;
-#endif
 }
 
 bool SupportsColoredOutput(fd_t fd) {
-  return isatty(fd) != 0;
+	Genode::error("sanitizer: ", __func__, " called");
+	return false;
 }
 
 #ifndef SANITIZER_GO
-// TODO(glider): different tools may require different altstack size.
-static const uptr kAltStackSize = SIGSTKSZ * 4;  // SIGSTKSZ is not enough.
 
 void SetAlternateSignalStack() {
-  stack_t altstack, oldstack;
-  CHECK_EQ(0, sigaltstack(nullptr, &oldstack));
-  // If the alternate stack is already in place, do nothing.
-  // Android always sets an alternate stack, but it's too small for us.
-  if (!SANITIZER_ANDROID && !(oldstack.ss_flags & SS_DISABLE)) return;
-  // TODO(glider): the mapped stack should have the MAP_STACK flag in the
-  // future. It is not required by man 2 sigaltstack now (they're using
-  // malloc()).
-  void* base = MmapOrDie(kAltStackSize, __func__);
-  altstack.ss_sp = (char*) base;
-  altstack.ss_flags = 0;
-  altstack.ss_size = kAltStackSize;
-  CHECK_EQ(0, sigaltstack(&altstack, nullptr));
+	Genode::error("sanitizer: ", __func__, " called");
 }
 
 void UnsetAlternateSignalStack() {
-  stack_t altstack, oldstack;
-  altstack.ss_sp = nullptr;
-  altstack.ss_flags = SS_DISABLE;
-  altstack.ss_size = kAltStackSize;  // Some sane value required on Darwin.
-  CHECK_EQ(0, sigaltstack(&altstack, &oldstack));
-  UnmapOrDie(oldstack.ss_sp, oldstack.ss_size);
-}
-
-typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
-static void MaybeInstallSigaction(int signum,
-                                  SignalHandlerType handler) {
-  if (!IsDeadlySignal(signum))
-    return;
-  struct sigaction sigact;
-  internal_memset(&sigact, 0, sizeof(sigact));
-  sigact.sa_sigaction = (sa_sigaction_t)handler;
-  // Do not block the signal from being received in that signal's handler.
-  // Clients are responsible for handling this correctly.
-  sigact.sa_flags = SA_SIGINFO | SA_NODEFER;
-  if (common_flags()->use_sigaltstack) sigact.sa_flags |= SA_ONSTACK;
-  CHECK_EQ(0, internal_sigaction(signum, &sigact, nullptr));
-  VReport(1, "Installed the sigaction for signal %d\n", signum);
+	Genode::error("sanitizer: ", __func__, " called");
 }
 
 void InstallDeadlySignalHandlers(SignalHandlerType handler) {
-  // Set the alternate signal stack for the main thread.
-  // This will cause SetAlternateSignalStack to be called twice, but the stack
-  // will be actually set only once.
-  if (common_flags()->use_sigaltstack) SetAlternateSignalStack();
-  MaybeInstallSigaction(SIGSEGV, handler);
-  MaybeInstallSigaction(SIGBUS, handler);
-  MaybeInstallSigaction(SIGABRT, handler);
-  MaybeInstallSigaction(SIGFPE, handler);
+	Genode::error("sanitizer: ", __func__, " called");
 }
 #endif  // SANITIZER_GO
 
 bool IsAccessibleMemoryRange(uptr beg, uptr size) {
-  uptr page_size = GetPageSizeCached();
-  // Checking too large memory ranges is slow.
-  CHECK_LT(size, page_size * 10);
-  int sock_pair[2];
-  if (pipe(sock_pair))
-    return false;
-  uptr bytes_written =
-      internal_write(sock_pair[1], reinterpret_cast<void *>(beg), size);
-  int write_errno;
-  bool result;
-  if (internal_iserror(bytes_written, &write_errno)) {
-    CHECK_EQ(EFAULT, write_errno);
-    result = false;
-  } else {
-    result = (bytes_written == size);
-  }
-  internal_close(sock_pair[0]);
-  internal_close(sock_pair[1]);
-  return result;
+	Genode::error("sanitizer: ", __func__, " called");
+  return true;
 }
 
 void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {
@@ -232,47 +160,19 @@ int GetNamedMappingFd(const char *name, uptr size) {
 }
 #else
 int GetNamedMappingFd(const char *name, uptr size) {
-  if (!common_flags()->decorate_proc_maps)
-    return -1;
-  char shmname[200];
-  CHECK(internal_strlen(name) < sizeof(shmname) - 10);
-  internal_snprintf(shmname, sizeof(shmname), "%zu [%s]", internal_getpid(),
-                    name);
-  int fd = shm_open(shmname, O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);
-  CHECK_GE(fd, 0);
-  int res = internal_ftruncate(fd, size);
-  CHECK_EQ(0, res);
-  res = shm_unlink(shmname);
-  CHECK_EQ(0, res);
-  return fd;
+	Genode::error("sanitizer: ", __func__, " called");
+  return -1;
 }
 #endif
 
 void *MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {
-  int fd = name ? GetNamedMappingFd(name, size) : -1;
-  unsigned flags = MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE;
-  if (fd == -1) flags |= MAP_ANON;
-
-  uptr PageSize = GetPageSizeCached();
-  uptr p = internal_mmap((void *)(fixed_addr & ~(PageSize - 1)),
-                         RoundUpTo(size, PageSize), PROT_READ | PROT_WRITE,
-                         flags, fd, 0);
-  int reserrno;
-  if (internal_iserror(p, &reserrno))
-    Report("ERROR: %s failed to "
-           "allocate 0x%zx (%zd) bytes at address %zx (errno: %d)\n",
-           SanitizerToolName, size, size, fixed_addr, reserrno);
-  IncreaseTotalMmap(size);
-  return (void *)p;
+	Genode::error("sanitizer: ", __func__, " called");
+  return nullptr;
 }
 
 void *MmapNoAccess(uptr fixed_addr, uptr size, const char *name) {
-  int fd = name ? GetNamedMappingFd(name, size) : -1;
-  unsigned flags = MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE;
-  if (fd == -1) flags |= MAP_ANON;
-
-  return (void *)internal_mmap((void *)fixed_addr, size, PROT_NONE, flags, fd,
-                               0);
+	Genode::error("sanitizer: ", __func__, " called");
+	return nullptr;
 }
 
 // This function is defined elsewhere if we intercepted pthread_attr_getstack.
@@ -282,38 +182,13 @@ real_pthread_attr_getstack(void *attr, void **addr, size_t *size);
 } // extern "C"
 
 int my_pthread_attr_getstack(void *attr, void **addr, uptr *size) {
-#if !SANITIZER_GO && !SANITIZER_MAC
-  if (&real_pthread_attr_getstack)
-    return real_pthread_attr_getstack((pthread_attr_t *)attr, addr,
-                                      (size_t *)size);
-#endif
-  return pthread_attr_getstack((pthread_attr_t *)attr, addr, (size_t *)size);
+	Genode::error("sanitizer: ", __func__, " called");
+	return -1;
 }
 
 #if !SANITIZER_GO
 void AdjustStackSize(void *attr_) {
-  pthread_attr_t *attr = (pthread_attr_t *)attr_;
-  uptr stackaddr = 0;
-  uptr stacksize = 0;
-  my_pthread_attr_getstack(attr, (void**)&stackaddr, &stacksize);
-  // GLibC will return (0 - stacksize) as the stack address in the case when
-  // stacksize is set, but stackaddr is not.
-  bool stack_set = (stackaddr != 0) && (stackaddr + stacksize != 0);
-  // We place a lot of tool data into TLS, account for that.
-  const uptr minstacksize = GetTlsSize() + 128*1024;
-  if (stacksize < minstacksize) {
-    if (!stack_set) {
-      if (stacksize != 0) {
-        VPrintf(1, "Sanitizer: increasing stacksize %zu->%zu\n", stacksize,
-                minstacksize);
-        pthread_attr_setstacksize(attr, minstacksize);
-      }
-    } else {
-      Printf("Sanitizer: pre-allocated stack size is insufficient: "
-             "%zu < %zu\n", stacksize, minstacksize);
-      Printf("Sanitizer: pthread_create is likely to fail.\n");
-    }
-  }
+	Genode::error("sanitizer: ", __func__, " called");
 }
 #endif // !SANITIZER_GO
 
diff --git a/libsanitizer/sanitizer_common/sanitizer_printf.cc b/libsanitizer/sanitizer_common/sanitizer_printf.cc
index 6688610..6efd98b 100644
--- a/libsanitizer/sanitizer_common/sanitizer_printf.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_printf.cc
@@ -16,7 +16,9 @@
 #include "sanitizer_flags.h"
 #include "sanitizer_libc.h"
 
+#if 0
 #include <stdio.h>
+#endif
 #include <stdarg.h>
 
 #if SANITIZER_WINDOWS && defined(_MSC_VER) && _MSC_VER < 1800 &&               \
diff --git a/libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc b/libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc
index e4ff525..d8d5fd4 100644
--- a/libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc
@@ -10,6 +10,8 @@
 // POSIX-specific implementation of symbolizer parts.
 //===----------------------------------------------------------------------===//
 
+#include <base/log.h>
+
 #include "sanitizer_platform.h"
 #if SANITIZER_POSIX
 #include "sanitizer_allocator_internal.h"
@@ -24,10 +26,14 @@
 #include "sanitizer_symbolizer_libbacktrace.h"
 #include "sanitizer_symbolizer_mac.h"
 
+#if 0
 #include <errno.h>
 #include <stdlib.h>
 #include <sys/wait.h>
 #include <unistd.h>
+#endif
+
+#include <stddef.h>
 
 #if SANITIZER_MAC
 #include <util.h>  // for forkpty()
@@ -60,128 +66,8 @@ const char *DemangleCXXABI(const char *name) {
 }
 
 bool SymbolizerProcess::StartSymbolizerSubprocess() {
-  if (!FileExists(path_)) {
-    if (!reported_invalid_path_) {
-      Report("WARNING: invalid path to external symbolizer!\n");
-      reported_invalid_path_ = true;
-    }
-    return false;
-  }
-
-  int pid;
-  if (use_forkpty_) {
-#if SANITIZER_MAC
-    fd_t fd = kInvalidFd;
-    // Use forkpty to disable buffering in the new terminal.
-    pid = forkpty(&fd, 0, 0, 0);
-    if (pid == -1) {
-      // forkpty() failed.
-      Report("WARNING: failed to fork external symbolizer (errno: %d)\n",
-             errno);
-      return false;
-    } else if (pid == 0) {
-      // Child subprocess.
-      const char *argv[kArgVMax];
-      GetArgV(path_, argv);
-      execv(path_, const_cast<char **>(&argv[0]));
-      internal__exit(1);
-    }
-
-    // Continue execution in parent process.
-    input_fd_ = output_fd_ = fd;
-
-    // Disable echo in the new terminal, disable CR.
-    struct termios termflags;
-    tcgetattr(fd, &termflags);
-    termflags.c_oflag &= ~ONLCR;
-    termflags.c_lflag &= ~ECHO;
-    tcsetattr(fd, TCSANOW, &termflags);
-#else  // SANITIZER_MAC
-    UNIMPLEMENTED();
-#endif  // SANITIZER_MAC
-  } else {
-    int *infd = NULL;
-    int *outfd = NULL;
-    // The client program may close its stdin and/or stdout and/or stderr
-    // thus allowing socketpair to reuse file descriptors 0, 1 or 2.
-    // In this case the communication between the forked processes may be
-    // broken if either the parent or the child tries to close or duplicate
-    // these descriptors. The loop below produces two pairs of file
-    // descriptors, each greater than 2 (stderr).
-    int sock_pair[5][2];
-    for (int i = 0; i < 5; i++) {
-      if (pipe(sock_pair[i]) == -1) {
-        for (int j = 0; j < i; j++) {
-          internal_close(sock_pair[j][0]);
-          internal_close(sock_pair[j][1]);
-        }
-        Report("WARNING: Can't create a socket pair to start "
-               "external symbolizer (errno: %d)\n", errno);
-        return false;
-      } else if (sock_pair[i][0] > 2 && sock_pair[i][1] > 2) {
-        if (infd == NULL) {
-          infd = sock_pair[i];
-        } else {
-          outfd = sock_pair[i];
-          for (int j = 0; j < i; j++) {
-            if (sock_pair[j] == infd) continue;
-            internal_close(sock_pair[j][0]);
-            internal_close(sock_pair[j][1]);
-          }
-          break;
-        }
-      }
-    }
-    CHECK(infd);
-    CHECK(outfd);
-
-    // Real fork() may call user callbacks registered with pthread_atfork().
-    pid = internal_fork();
-    if (pid == -1) {
-      // Fork() failed.
-      internal_close(infd[0]);
-      internal_close(infd[1]);
-      internal_close(outfd[0]);
-      internal_close(outfd[1]);
-      Report("WARNING: failed to fork external symbolizer "
-             " (errno: %d)\n", errno);
-      return false;
-    } else if (pid == 0) {
-      // Child subprocess.
-      internal_close(STDOUT_FILENO);
-      internal_close(STDIN_FILENO);
-      internal_dup2(outfd[0], STDIN_FILENO);
-      internal_dup2(infd[1], STDOUT_FILENO);
-      internal_close(outfd[0]);
-      internal_close(outfd[1]);
-      internal_close(infd[0]);
-      internal_close(infd[1]);
-      for (int fd = sysconf(_SC_OPEN_MAX); fd > 2; fd--)
-        internal_close(fd);
-      const char *argv[kArgVMax];
-      GetArgV(path_, argv);
-      execv(path_, const_cast<char **>(&argv[0]));
-      internal__exit(1);
-    }
-
-    // Continue execution in parent process.
-    internal_close(outfd[0]);
-    internal_close(infd[1]);
-    input_fd_ = infd[0];
-    output_fd_ = outfd[1];
-  }
-
-  // Check that symbolizer subprocess started successfully.
-  int pid_status;
-  SleepForMillis(kSymbolizerStartupTimeMillis);
-  int exited_pid = waitpid(pid, &pid_status, WNOHANG);
-  if (exited_pid != 0) {
-    // Either waitpid failed, or child has already exited.
-    Report("WARNING: external symbolizer didn't start up correctly!\n");
-    return false;
-  }
-
-  return true;
+	Genode::error("sanitizer: ", __func__, " called");
+  return false;
 }
 
 class Addr2LineProcess : public SymbolizerProcess {
diff --git a/libsanitizer/ubsan/ubsan_diag.cc b/libsanitizer/ubsan/ubsan_diag.cc
index 1197f83..8ffa8fe 100644
--- a/libsanitizer/ubsan/ubsan_diag.cc
+++ b/libsanitizer/ubsan/ubsan_diag.cc
@@ -20,7 +20,9 @@
 #include "sanitizer_common/sanitizer_stacktrace_printer.h"
 #include "sanitizer_common/sanitizer_suppressions.h"
 #include "sanitizer_common/sanitizer_symbolizer.h"
+#if 0
 #include <stdio.h>
+#endif
 
 using namespace __ubsan;
 
@@ -204,8 +206,10 @@ static void renderText(const char *Message, const Diag::Arg *Args) {
 #if SANITIZER_WINDOWS
         sprintf_s(Buffer, sizeof(Buffer), "%Lg", (long double)A.Float);
 #else
+#if 0
         snprintf(Buffer, sizeof(Buffer), "%Lg", (long double)A.Float);
 #endif
+#endif
         Printf("%s", Buffer);
         break;
       }
