xpcom.diff

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 include/sdk/VirtualBox_XPCOM.h            |    4 
 src/VBox/Main/include/ClientToken.h       |  105 ++++++
 src/VBox/Main/include/DisplayImpl.h       |    3 
 src/VBox/Main/include/HostUSBDeviceImpl.h |   10 -
 src/VBox/Main/include/SessionImpl.h       |   11 -
 src/VBox/Main/include/Wrapper.h           |  491 +++++++++++++++++++++++++++++
 src/VBox/Main/src-client/ConsoleImpl.cpp  |   16 +
 src/VBox/Main/src-server/MachineImpl.cpp  |    4 
 src/VBox/Main/src-server/MediumImpl.cpp   |    1 
 9 files changed, 618 insertions(+), 27 deletions(-)
 create mode 100644 src/VBox/Main/include/ClientToken.h
 create mode 100644 src/VBox/Main/include/Wrapper.h

diff --git a/include/sdk/VirtualBox_XPCOM.h b/include/sdk/VirtualBox_XPCOM.h
index f096daf..cffe0b7 100644
--- a/include/sdk/VirtualBox_XPCOM.h
+++ b/include/sdk/VirtualBox_XPCOM.h
@@ -7,11 +7,11 @@
 
 
 #ifndef __gen_nsISupports_h__
-#include "nsISupports.h"
+//#include "nsISupports.h"
 #endif
 
 #ifndef __gen_nsIException_h__
-#include "nsIException.h"
+//#include "nsIException.h"
 #endif
 
 /* For IDL files that don't want to include root IDL files. */
diff --git a/src/VBox/Main/include/ClientToken.h b/src/VBox/Main/include/ClientToken.h
new file mode 100644
index 0000000..d452269
--- /dev/null
+++ b/src/VBox/Main/include/ClientToken.h
@@ -0,0 +1,105 @@
+/* $Id: ClientToken.h $ */
+
+/** @file
+ *
+ * VirtualBox API client session token abstraction
+ */
+
+/*
+ * Copyright (C) 2013 Oracle Corporation
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ */
+
+#ifndef ____H_CLIENTTOKEN
+#define ____H_CLIENTTOKEN
+
+#include <VBox/com/ptr.h>
+#include <VBox/com/AutoLock.h>
+
+#include "MachineImpl.h"
+#ifdef VBOX_WITH_GENERIC_SESSION_WATCHER
+# include "TokenImpl.h"
+#endif /* VBOX_WITH_GENERIC_SESSION_WATCHER */
+
+#if defined(RT_OS_WINDOWS)
+# define CTTOKENARG NULL
+# define CTTOKENTYPE HANDLE
+#elif defined(RT_OS_OS2)
+# define CTTOKENARG NULLHANDLE
+# define CTTOKENTYPE HMTX
+#elif defined(VBOX_WITH_SYS_V_IPC_SESSION_WATCHER)
+# define CTTOKENARG -1
+# define CTTOKENTYPE int
+#elif defined(VBOX_WITH_GENERIC_SESSION_WATCHER)
+# define CTTOKENARG NULL
+# define CTTOKENTYPE MachineToken *
+#else
+# error "Port me!"
+#endif
+
+/**
+ * Class which represents a token which can be used to check for client
+ * crashes and similar purposes.
+ */
+class Machine::ClientToken
+{
+public:
+    /**
+     * Constructor which creates a usable instance
+     *
+     * @param pMachine          Reference to Machine object
+     * @param pSessionMachine   Reference to corresponding SessionMachine object
+     */
+    ClientToken(const ComObjPtr<Machine> &pMachine, SessionMachine *pSessionMachine);
+
+    /**
+     * Default destructor. Cleans everything up.
+     */
+    ~ClientToken();
+
+    /**
+     * Check if object contains a usable token.
+     */
+    bool isReady();
+
+    /**
+     * Query token ID, which is a unique string value for this token. Do not
+     * assume any specific content/format, it is opaque information.
+     */
+    void getId(Utf8Str &strId);
+
+    /**
+     * Query token, which is platform dependent.
+     */
+    CTTOKENTYPE getToken();
+
+#ifndef VBOX_WITH_GENERIC_SESSION_WATCHER
+    /**
+     * Release token now. Returns information if the client has terminated.
+     */
+    bool release();
+#endif /* !VBOX_WITH_GENERIC_SESSION_WATCHER */
+
+private:
+    /**
+     * Default constructor. Don't use, will not create a sensible instance.
+     */
+    ClientToken();
+
+    Machine *mMachine;
+    CTTOKENTYPE mClientToken;
+    Utf8Str mClientTokenId;
+#ifdef VBOX_WITH_GENERIC_SESSION_WATCHER
+    bool mClientTokenPassed;
+#endif
+};
+
+#endif /* !____H_CLIENTTOKEN */
+/* vi: set tabstop=4 shiftwidth=4 expandtab: */
diff --git a/src/VBox/Main/include/DisplayImpl.h b/src/VBox/Main/include/DisplayImpl.h
index 368453c..ecb58b9 100644
--- a/src/VBox/Main/include/DisplayImpl.h
+++ b/src/VBox/Main/include/DisplayImpl.h
@@ -132,7 +132,6 @@ class VMMDev;
 
 class ATL_NO_VTABLE Display :
     public VirtualBoxBase,
-    public IEventListener,
     VBOX_SCRIPTABLE_IMPL(IEventListener),
     VBOX_SCRIPTABLE_IMPL(IDisplay),
     public DisplayMouseInterface
@@ -233,7 +232,9 @@ public:
 
     static const PDMDRVREG  DrvReg;
 
+#if 0
     static void fireGuestMonitorChangedEvent(EventSource*, GuestMonitorChangedEventType, int32_t, int32_t, int32_t, int32_t, int32_t);
+#endif
 
 private:
 
diff --git a/src/VBox/Main/include/HostUSBDeviceImpl.h b/src/VBox/Main/include/HostUSBDeviceImpl.h
index 2b9e7a1..57023e1 100644
--- a/src/VBox/Main/include/HostUSBDeviceImpl.h
+++ b/src/VBox/Main/include/HostUSBDeviceImpl.h
@@ -168,15 +168,7 @@ typedef enum
  * Object class used to hold Host USB Device properties.
  */
 class ATL_NO_VTABLE HostUSBDevice :
-	/*
-	 * Genode:
-	 *
-	 * Both 'HostUSBDevice' and 'OUSBDevice' must be compatible with
-	 * 'IUSBDevice'. 'IUSBDevice' is typedef'd as 'OUSBDevice' on Genode,
-	 * and 'HostUSBDevice' inherits 'IUSBDevice'. Since 'OUSBDevice' already
-	 * inherits 'VirtualBoxBase', 'HostUSBDevice' does not do it again.
-	 */
-    public IUSBDevice,
+    public VirtualBoxBase,
     VBOX_SCRIPTABLE_IMPL(IHostUSBDevice)
 {
 public:
diff --git a/src/VBox/Main/include/SessionImpl.h b/src/VBox/Main/include/SessionImpl.h
index 0db9d2c..bcd6b4c 100644
--- a/src/VBox/Main/include/SessionImpl.h
+++ b/src/VBox/Main/include/SessionImpl.h
@@ -30,18 +30,9 @@ class GenodeConsole;
 [threading(free)]
 #endif
 class ATL_NO_VTABLE Session :
-    public VirtualBoxBase
-#if 0
-    /*
-     * Genode:
-     *
-     * Because both 'ISession' and 'IInternalSessionControl' are typedef'd as
-     * 'Session', 'Session' would inherit from 'DummyClass<Session>' twice,
-     * which is not allowed.
-     */
+    public VirtualBoxBase,
     VBOX_SCRIPTABLE_IMPL(ISession),
     VBOX_SCRIPTABLE_IMPL(IInternalSessionControl)
-#endif
 #ifdef RT_OS_WINDOWS
     , public CComCoClass<Session, &CLSID_Session>
 #endif
diff --git a/src/VBox/Main/include/Wrapper.h b/src/VBox/Main/include/Wrapper.h
new file mode 100644
index 0000000..2381ea2
--- /dev/null
+++ b/src/VBox/Main/include/Wrapper.h
@@ -0,0 +1,491 @@
+/* $Id: Wrapper.h $ */
+/** @file
+ * VirtualBox COM: API wrapper helpers
+ */
+
+/*
+ * Copyright (C) 2012-2014 Oracle Corporation
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ */
+
+#ifndef ____H_WRAPPER
+#define ____H_WRAPPER
+
+#include <vector>
+#include <VBox/com/ptr.h>
+#include <VBox/com/array.h>
+
+#include "AutoCaller.h"
+
+
+/**
+ * Checks that the given pointer to an output argument is valid and throws
+ * E_POINTER + extended error info otherwise.
+ * @param arg   Pointer argument.
+ */
+#define CheckComArgOutPointerValidThrow(arg) \
+    do { \
+        if (RT_UNLIKELY(!VALID_PTR(arg))) \
+            throw setError(E_POINTER, \
+                tr("Output argument %s points to invalid memory location (%p)"), \
+                #arg, (void *)(arg)); \
+    } while (0)
+
+
+class BSTROutConverter
+{
+public:
+    BSTROutConverter() : mDst(NULL)
+    {
+    }
+
+    BSTROutConverter(BSTR *aDst) : mDst(aDst)
+    {
+    }
+
+    ~BSTROutConverter()
+    {
+        if (mDst)
+            Bstr(mStr).detachTo(mDst);
+    }
+
+    com::Utf8Str &str()
+    {
+        return mStr;
+    }
+
+private:
+    com::Utf8Str mStr;
+    BSTR *mDst;
+};
+
+class BSTRInConverter
+{
+public:
+    BSTRInConverter() : mSrc()
+    {
+    }
+
+    BSTRInConverter(CBSTR aSrc) : mSrc(aSrc)
+    {
+    }
+
+    ~BSTRInConverter()
+    {
+    }
+
+    const com::Utf8Str &str()
+    {
+        return mSrc;
+    }
+
+private:
+    const com::Utf8Str mSrc;
+};
+
+class ArrayBSTROutConverter
+{
+public:
+    ArrayBSTROutConverter() :
+#ifdef VBOX_WITH_XPCOM
+        mDstSize(NULL),
+        mDst(NULL)
+#else // !VBOX_WITH_XPCOM
+        mDst(NULL)
+#endif // !VBOX_WITH_XPCOM
+    {
+    }
+
+    ArrayBSTROutConverter(ComSafeArrayOut(BSTR, aDst)) :
+#ifdef VBOX_WITH_XPCOM
+        mDstSize(aDstSize),
+        mDst(aDst)
+#else // !VBOX_WITH_XPCOM
+        mDst(aDst)
+#endif // !VBOX_WITH_XPCOM
+    {
+    }
+
+    ~ArrayBSTROutConverter()
+    {
+        if (mDst)
+        {
+            com::SafeArray<BSTR> outArray(mArray.size());
+            for (size_t i = 0; i < mArray.size(); i++)
+                Bstr(mArray[i]).detachTo(&outArray[i]);
+            outArray.detachTo(ComSafeArrayOutArg(mDst));
+        }
+    }
+
+    std::vector<com::Utf8Str> &array()
+    {
+        return mArray;
+    }
+
+private:
+    std::vector<com::Utf8Str> mArray;
+#ifdef VBOX_WITH_XPCOM
+    PRUint32 *mDstSize;
+    BSTR **mDst;
+#else // !VBOX_WITH_XPCOM
+    SAFEARRAY **mDst;
+#endif // !VBOX_WITH_XPCOM
+};
+
+class ArrayBSTRInConverter
+{
+public:
+    ArrayBSTRInConverter()
+    {
+    }
+
+    ArrayBSTRInConverter(ComSafeArrayIn(IN_BSTR, aSrc))
+    {
+        if (!ComSafeArrayInIsNull(aSrc))
+        {
+            com::SafeArray<IN_BSTR> inArray(ComSafeArrayInArg(aSrc));
+            mArray.resize(inArray.size());
+            for (size_t i = 0; i < inArray.size(); i++)
+                mArray[i] = inArray[i];
+        }
+    }
+
+    ~ArrayBSTRInConverter()
+    {
+    }
+
+    const std::vector<com::Utf8Str> &array()
+    {
+        return mArray;
+    }
+
+private:
+    std::vector<com::Utf8Str> mArray;
+};
+
+class UuidOutConverter
+{
+public:
+    UuidOutConverter() : mDst(NULL)
+    {
+    }
+
+    UuidOutConverter(BSTR *aDst) : mDst(aDst)
+    {
+    }
+
+    ~UuidOutConverter()
+    {
+        if (mDst)
+            mUuid.toUtf16().detachTo(mDst);
+    }
+
+    com::Guid &uuid()
+    {
+        return mUuid;
+    }
+
+private:
+    com::Guid mUuid;
+    BSTR *mDst;
+};
+
+class UuidInConverter
+{
+public:
+    UuidInConverter() : mSrc()
+    {
+    }
+
+    UuidInConverter(CBSTR aSrc) : mSrc(aSrc)
+    {
+    }
+
+    ~UuidInConverter()
+    {
+    }
+
+    const com::Guid &uuid()
+    {
+        return mSrc;
+    }
+
+private:
+    const com::Guid mSrc;
+};
+
+class ArrayUuidOutConverter
+{
+public:
+    ArrayUuidOutConverter() :
+#ifdef VBOX_WITH_XPCOM
+        mDstSize(NULL),
+        mDst(NULL)
+#else // !VBOX_WITH_XPCOM
+        mDst(NULL)
+#endif // !VBOX_WITH_XPCOM
+    {
+    }
+
+    ArrayUuidOutConverter(ComSafeArrayOut(BSTR, aDst)) :
+#ifdef VBOX_WITH_XPCOM
+        mDstSize(aDstSize),
+        mDst(aDst)
+#else // !VBOX_WITH_XPCOM
+        mDst(aDst)
+#endif // !VBOX_WITH_XPCOM
+    {
+    }
+
+    ~ArrayUuidOutConverter()
+    {
+        if (mDst)
+        {
+            com::SafeArray<BSTR> outArray(mArray.size());
+            for (size_t i = 0; i < mArray.size(); i++)
+                mArray[i].toUtf16().detachTo(&outArray[i]);
+            outArray.detachTo(ComSafeArrayOutArg(mDst));
+        }
+    }
+
+    std::vector<com::Guid> &array()
+    {
+        return mArray;
+    }
+
+private:
+    std::vector<com::Guid> mArray;
+#ifdef VBOX_WITH_XPCOM
+    PRUint32 *mDstSize;
+    BSTR **mDst;
+#else // !VBOX_WITH_XPCOM
+    SAFEARRAY **mDst;
+#endif // !VBOX_WITH_XPCOM
+};
+
+template <class A>
+class ComTypeOutConverter
+{
+public:
+    ComTypeOutConverter() : mDst(NULL)
+    {
+    }
+
+    ComTypeOutConverter(A **aDst) : mDst(aDst)
+    {
+    }
+
+    ~ComTypeOutConverter()
+    {
+        if (mDst)
+            mPtr.queryInterfaceTo(mDst);
+    }
+
+    ComPtr<A> &ptr()
+    {
+        return mPtr;
+    }
+
+private:
+    ComPtr<A> mPtr;
+    A **mDst;
+};
+
+template <class A>
+class ComTypeInConverter
+{
+public:
+    ComTypeInConverter() : mSrc(NULL)
+    {
+    }
+
+    ComTypeInConverter(A *aSrc) : mSrc(aSrc)
+    {
+    }
+
+    ~ComTypeInConverter()
+    {
+    }
+
+    const ComPtr<A> &ptr()
+    {
+        return mSrc;
+    }
+
+private:
+    const ComPtr<A> mSrc;
+};
+
+template <class A>
+class ArrayComTypeOutConverter
+{
+public:
+    ArrayComTypeOutConverter() :
+#ifdef VBOX_WITH_XPCOM
+        mDstSize(NULL),
+        mDst(NULL)
+#else // !VBOX_WITH_XPCOM
+        mDst(NULL)
+#endif // !VBOX_WITH_XPCOM
+    {
+    }
+
+    ArrayComTypeOutConverter(ComSafeArrayOut(A *, aDst)) :
+#ifdef VBOX_WITH_XPCOM
+        mDstSize(aDstSize),
+        mDst(aDst)
+#else // !VBOX_WITH_XPCOM
+        mDst(aDst)
+#endif // !VBOX_WITH_XPCOM
+    {
+    }
+
+    ~ArrayComTypeOutConverter()
+    {
+        if (mDst)
+        {
+            com::SafeIfaceArray<A> outArray(mArray.size());
+            for (size_t i = 0; i < mArray.size(); i++)
+                outArray[i] = mArray[i];
+            outArray.detachTo(ComSafeArrayOutArg(mDst));
+        }
+    }
+
+    std::vector<ComPtr<A> > &array()
+    {
+        return mArray;
+    }
+
+private:
+    std::vector<ComPtr<A> > mArray;
+#ifdef VBOX_WITH_XPCOM
+    PRUint32 *mDstSize;
+    A ***mDst;
+#else // !VBOX_WITH_XPCOM
+    SAFEARRAY **mDst;
+#endif // !VBOX_WITH_XPCOM
+};
+
+template <class A>
+class ArrayComTypeInConverter
+{
+public:
+    ArrayComTypeInConverter()
+    {
+    }
+
+    ArrayComTypeInConverter(ComSafeArrayIn(A *, aSrc))
+    {
+        if (!ComSafeArrayInIsNull(aSrc))
+        {
+            com::SafeIfaceArray<A> inArray(ComSafeArrayInArg(aSrc));
+            mArray.resize(inArray.size());
+            for (size_t i = 0; i < inArray.size(); i++)
+                mArray[i] = inArray[i];
+        }
+    }
+
+    ~ArrayComTypeInConverter()
+    {
+    }
+
+    const std::vector<ComPtr<A> > &array()
+    {
+        return mArray;
+    }
+
+private:
+    std::vector<ComPtr<A> > mArray;
+};
+
+template <typename A>
+class ArrayOutConverter
+{
+public:
+    ArrayOutConverter() :
+#ifdef VBOX_WITH_XPCOM
+        mDstSize(NULL),
+        mDst(NULL)
+#else // !VBOX_WITH_XPCOM
+        mDst(NULL)
+#endif // !VBOX_WITH_XPCOM
+    {
+    }
+
+    ArrayOutConverter(ComSafeArrayOut(A, aDst)) :
+#ifdef VBOX_WITH_XPCOM
+        mDstSize(aDstSize),
+        mDst(aDst)
+#else // !VBOX_WITH_XPCOM
+        mDst(aDst)
+#endif // !VBOX_WITH_XPCOM
+    {
+    }
+
+    ~ArrayOutConverter()
+    {
+        if (mDst)
+        {
+            com::SafeArray<A> outArray(mArray.size());
+            for (size_t i = 0; i < mArray.size(); i++)
+                outArray[i] = mArray[i];
+            outArray.detachTo(ComSafeArrayOutArg(mDst));
+        }
+    }
+
+    std::vector<A> &array()
+    {
+        return mArray;
+    }
+
+private:
+    std::vector<A> mArray;
+#ifdef VBOX_WITH_XPCOM
+    PRUint32 *mDstSize;
+    A **mDst;
+#else // !VBOX_WITH_XPCOM
+    SAFEARRAY **mDst;
+#endif // !VBOX_WITH_XPCOM
+};
+
+template <typename A>
+class ArrayInConverter
+{
+public:
+    ArrayInConverter()
+    {
+    }
+
+    ArrayInConverter(ComSafeArrayIn(A, aSrc))
+    {
+        if (!ComSafeArrayInIsNull(aSrc))
+        {
+            com::SafeArray<A> inArray(ComSafeArrayInArg(aSrc));
+            mArray.resize(inArray.size());
+            for (size_t i = 0; i < inArray.size(); i++)
+                mArray[i] = inArray[i];
+        }
+    }
+
+    ~ArrayInConverter()
+    {
+    }
+
+    const std::vector<A> &array()
+    {
+        return mArray;
+    }
+
+private:
+    std::vector<A> mArray;
+};
+
+#endif // !____H_WRAPPER
+/* vi: set tabstop=4 shiftwidth=4 expandtab: */
diff --git a/src/VBox/Main/src-client/ConsoleImpl.cpp b/src/VBox/Main/src-client/ConsoleImpl.cpp
index 72f18e1..6291b2f 100644
--- a/src/VBox/Main/src-client/ConsoleImpl.cpp
+++ b/src/VBox/Main/src-client/ConsoleImpl.cpp
@@ -51,10 +51,11 @@
 #include "KeyboardImpl.h"
 #include "MouseImpl.h"
 #include "DisplayImpl.h"
-#include "MachineImpl.h"
 #if 0
 #include "MachineDebuggerImpl.h"
+#endif
 #include "USBDeviceImpl.h"
+#if 0
 #include "RemoteUSBDeviceImpl.h"
 #endif
 #include "SharedFolderImpl.h"
@@ -64,15 +65,20 @@
 #ifdef VBOX_WITH_USB_CARDREADER
 # include "UsbCardReader.h"
 #endif
+#endif
 #include "ProgressImpl.h"
+#if 0
 #include "ConsoleVRDPServer.h"
+#endif
 #include "VMMDev.h"
+#if 0
 #ifdef VBOX_WITH_EXTPACK
 # include "ExtPackManagerImpl.h"
 #endif
 #include "BusAssignmentManager.h"
 #include "EmulatedUSBImpl.h"
 #endif
+#include "VirtualBoxImpl.h"
 
 #include "VBoxEvents.h"
 #include "AutoCaller.h"
@@ -7176,8 +7182,10 @@ HRESULT Console::powerUp(IProgress **aProgress, bool aPaused)
         }
 #endif
 
-        ComPtr<IVirtualBox> pVirtualBox;
-        mMachine->COMGETTER(Parent)(pVirtualBox.asOutParam());
+        ComPtr<IVirtualBox> pIVirtualBox;
+        mMachine->COMGETTER(Parent)(pIVirtualBox.asOutParam());
+		VirtualBox *pVirtualBox =
+			dynamic_cast<VirtualBox*>(*pIVirtualBox.asOutParam());
 
         // If there is immutable drive the process that.
         VMPowerUpTask::ProgressList progresses(task->hardDiskProgresses);
@@ -7468,6 +7476,7 @@ HRESULT Console::powerDown(IProgress *aProgress /*= NULL*/)
      * safe to release the object lock now if needed)
      * ---------------------------------------------------------------------- */
 
+#if 0
     /* Stop the VRDP server to prevent new clients connection while VM is being
      * powered off. */
     if (mConsoleVRDPServer)
@@ -7482,6 +7491,7 @@ HRESULT Console::powerDown(IProgress *aProgress /*= NULL*/)
 
         alock.acquire();
     }
+#endif
 
     /* advance percent count */
     if (aProgress)
diff --git a/src/VBox/Main/src-server/MachineImpl.cpp b/src/VBox/Main/src-server/MachineImpl.cpp
index 984165a..0009cfd 100644
--- a/src/VBox/Main/src-server/MachineImpl.cpp
+++ b/src/VBox/Main/src-server/MachineImpl.cpp
@@ -3936,7 +3936,7 @@ STDMETHODIMP Machine::LaunchVMProcess(ISession *aSession,
         ComObjPtr<ProgressProxy> progress;
         progress.createObject();
         rc = progress->init(mParent,
-                            nullptr,
+                            static_cast<IMachine*>(this),
                             Bstr(tr("Starting VM")).raw(),
                             TRUE /* aCancelable */,
                             fTeleporterEnabled ? 20 : 10 /* uTotalOperationsWeight */,
@@ -5613,7 +5613,7 @@ STDMETHODIMP Machine::DeleteConfig(ComSafeArrayIn(IMedium*, aMedia), IProgress *
 
     pTask->pProgress.createObject();
     pTask->pProgress->init(getVirtualBox(),
-                           nullptr /* aInitiator */,
+                           static_cast<IMachine*>(this) /* aInitiator */,
                            Bstr(tr("Deleting files")).raw(),
                            true /* fCancellable */,
                            pTask->llFilesToDelete.size() + pTask->llMediums.size() + 1,   // cOperations
diff --git a/src/VBox/Main/src-server/MediumImpl.cpp b/src/VBox/Main/src-server/MediumImpl.cpp
index 893ac88..ed4bb7a 100644
--- a/src/VBox/Main/src-server/MediumImpl.cpp
+++ b/src/VBox/Main/src-server/MediumImpl.cpp
@@ -22,6 +22,7 @@
 #include "VirtualBoxImpl.h"
 #include "TokenImpl.h"
 
+#include "Global.h"
 #include "AutoCaller.h"
 #include "Logging.h"
 
