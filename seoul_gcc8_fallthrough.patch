seoul_gcc8_fallthrough.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 executor/vbios_keyboard.cc      |    2 -
 genode/include/service/string.h |    6 +--
 model/intel82576vf.cc           |    2 -
 model/pic8259.cc                |    2 +
 model/pit8254.cc                |    5 ++
 model/ps2keyboard.cc            |    3 +
 model/ps2mouse.cc               |    2 +
 model/rtc146818.cc              |    2 -
 model/rtl8029.cc                |    6 +--
 model/satadrive.cc              |    3 +
 model/serial16550.cc            |    1 
 model/vbios.cc                  |   92 ++++++++++++++++++++-------------------
 12 files changed, 70 insertions(+), 56 deletions(-)

diff --git a/executor/vbios_keyboard.cc b/executor/vbios_keyboard.cc
index 984d204..9c856af 100644
--- a/executor/vbios_keyboard.cc
+++ b/executor/vbios_keyboard.cc
@@ -159,7 +159,7 @@ class VirtualBiosKeyboard : public StaticReceiver<VirtualBiosKeyboard>, public B
       case 0x12: // get pressed state of various keys
         /* not supported, but there the status bits should be */
         cpu->ah = read_bda(0x18);
-        /* fall through */
+        [[gnu::fallthrough]];
       case 0x02: // get enable state of various keys
         cpu->al = read_bda(0x17);
         break;
diff --git a/model/intel82576vf.cc b/model/intel82576vf.cc
index ce006c4..a2ac76a 100644
--- a/model/intel82576vf.cc
+++ b/model/intel82576vf.cc
@@ -925,7 +925,7 @@ public:
       } else {
 	// If _txpoll_us is zero, we don't map TX registers and don't
 	// need to poll.
-	// FALLTHROUGH
+	[[gnu::fallthrough]];
       }
     default:
       return false;
diff --git a/model/pic8259.cc b/model/pic8259.cc
index e6a0cce..d590230 100644
--- a/model/pic8259.cc
+++ b/model/pic8259.cc
@@ -314,6 +314,7 @@ class PicDevice : public StaticReceiver<PicDevice>
 		  _icw[ICW3] = msg.value;
 		  break;
 		}
+		[[gnu::fallthrough]];
 	    case ICW4:
 	      _icw_mode = OCW1;
 	      if (_icw[ICW1] & ICW1_IC4)
@@ -321,6 +322,7 @@ class PicDevice : public StaticReceiver<PicDevice>
 		  _icw[ICW4] = msg.value;
 		  break;
 		}
+		[[gnu::fallthrough]];
 	    case OCW1:
 	      _imr = msg.value;
 	      propagate_irq(true);
diff --git a/model/ps2keyboard.cc b/model/ps2keyboard.cc
index 95c7a3d..cc26a96 100644
--- a/model/ps2keyboard.cc
+++ b/model/ps2keyboard.cc
@@ -268,6 +268,7 @@ class PS2Keyboard : public StaticReceiver<PS2Keyboard>
 	  {
 	  case 0xf0: // set scanset
 	    _pwrite = _pread = 0;
+	    [[gnu::fallthrough]];
 	  case 0xed: // set indicators
 	  case 0xf3: // set typematic rate/delay
 	  case 0xfb: // set key type typematic
@@ -313,6 +314,7 @@ class PS2Keyboard : public StaticReceiver<PS2Keyboard>
 	      {
 	      case 0xed: // set indicators
 		_indicators = msg.value;
+		[[gnu::fallthrough]];
 	      case 0xf3: // set typematic rate/delay
 		command = 0;
 		break;
@@ -337,6 +339,7 @@ class PS2Keyboard : public StaticReceiver<PS2Keyboard>
 		  _no_breakcode[msg.value >> 3] &= ~(1 << (msg.value & 7));
 		else
 		  _no_breakcode[msg.value >> 3] |= 1 << (msg.value & 7);
+		  [[gnu::fallthrough]];
 	      case 0xfb: // set key type typematic
 		if (msg.value)
 		  command = _last_command;
diff --git a/model/ps2mouse.cc b/model/ps2mouse.cc
index 03ff666..dc046f8 100644
--- a/model/ps2mouse.cc
+++ b/model/ps2mouse.cc
@@ -208,6 +208,7 @@ class PS2Mouse : public StaticReceiver<PS2Mouse>
 		packet = msg.value << 8 | 1;
 		break;
 	      }
+	      [[gnu::fallthrough]];
 	  default:
 	  case PARAM_NONE:
 	    packet = 0xfa01;
@@ -264,6 +265,7 @@ class PS2Mouse : public StaticReceiver<PS2Mouse>
 		break;
 	      default:
 		Logging::printf("%s(%x, %x) unknown command\n", __PRETTY_FUNCTION__, msg.port, msg.value);
+		[[gnu::fallthrough]];
 	      case 0xe1: // read secondary ID - used to identify trackpoints
 		packet = 0xfc01;
 	      }
diff --git a/model/rtc146818.cc b/model/rtc146818.cc
index d6837bd..fd7514c 100644
--- a/model/rtc146818.cc
+++ b/model/rtc146818.cc
@@ -387,7 +387,7 @@ public:
 	    if ((_ram[0xb] & 0x80) && ~msg.value & 0x80)
 	      // skip missed updates, but do not reset the divider chain
 	      _last = _clock.clock(FREQ);
-	    // Fallthrough
+	    [[gnu::fallthrough]];
 	  default:
 	    _ram[_index] = msg.value;
 	  }
diff --git a/model/rtl8029.cc b/model/rtl8029.cc
index aff5aca..73fe1d8 100644
--- a/model/rtl8029.cc
+++ b/model/rtl8029.cc
@@ -247,10 +247,10 @@ class Rtl8029: public StaticReceiver<Rtl8029>
 	  {
 	  case 0x3: _regs.bnry = value;   break;
 	  case 0x7: _regs.isr &= ~value | 0x80; break;
-	  case 0xd: value &= 0x1f;
-	  case 0xc: value &= 0x3f;
+	  case 0xd: value &= 0x1f; [[gnu::fallthrough]];
+	  case 0xc: value &= 0x3f; [[gnu::fallthrough]];
 	  case 0xe:
-	  case 0xf: value &= 0x7f;
+	  case 0xf: value &= 0x7f; [[gnu::fallthrough]];
 	  case 0x1:
 	  case 0x2:
 	  case 0x4 ... 0x6:
diff --git a/model/satadrive.cc b/model/satadrive.cc
index 620e02e..f1ff05d 100644
--- a/model/satadrive.cc
+++ b/model/satadrive.cc
@@ -259,6 +259,7 @@ class SataDrive : public FisReceiver, public StaticReceiver<SataDrive>
       case 0x25: // READ DMA EXT
       case 0x29: // READ MULTIPLE EXT
 	lba48_command = true;
+	[[gnu::fallthrough]];
       case 0x20: // READ SECTOR
       case 0xc4: // READ MULTIPLE
       case 0xc8: // READ DMA
@@ -272,6 +273,7 @@ class SataDrive : public FisReceiver, public StaticReceiver<SataDrive>
       case 0x35: // WRITE DMA EXT
       case 0x39: // WRITE MULTIPLE EXT
 	lba48_command = true;
+	[[gnu::fallthrough]];
       case 0x30: // WRITE SECTOR
       case 0xc5: // WRITE MULITIPLE
       case 0xca: // WRITE DMA
@@ -283,6 +285,7 @@ class SataDrive : public FisReceiver, public StaticReceiver<SataDrive>
 	break;
       case 0x60: // READ  FPDMA QUEUED
 	read = true;
+	[[gnu::fallthrough]];
       case 0x61: // WRITE FPDMA QUEUED
 	{
 	  // some idiot has switched feature and sector count regs in this case!
diff --git a/model/serial16550.cc b/model/serial16550.cc
index eefbae8..7a44024 100644
--- a/model/serial16550.cc
+++ b/model/serial16550.cc
@@ -223,6 +223,7 @@ public:
 	  msg.value &= _rfcount ? 0x1e : 0x2;
 	else
 	  msg.value &= 0x1f;
+	[[gnu::fallthrough]];
       case SCR ... DLM:
 	_regs[offset] = msg.value;
 	break;
