egl.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 include/EGL/eglplatform.h                          |   14 +
 src/egl/main/egldisplay.c                          |    3 
 src/egl/main/egldisplay.h                          |    1 
 src/egl/main/egldriver.c                           |   10 +
 src/gallium/state_trackers/egl/common/egl_g3d.c    |    6 
 .../state_trackers/egl/genode/native_genode.cc     |  242 ++++++++++++++++++++
 src/gallium/targets/egl-static/egl.c               |    3 
 7 files changed, 277 insertions(+), 2 deletions(-)
 create mode 100644 src/gallium/state_trackers/egl/genode/native_genode.cc

diff --git a/include/EGL/eglplatform.h b/include/EGL/eglplatform.h
index 21b18fe..75fde41 100644
--- a/include/EGL/eglplatform.h
+++ b/include/EGL/eglplatform.h
@@ -104,6 +104,20 @@ typedef struct ANativeWindow        *EGLNativeWindowType;
 typedef struct egl_native_pixmap_t  *EGLNativePixmapType;
 typedef void                        *EGLNativeDisplayType;
 
+#elif defined (GENODE_EGL_PLATFORM)
+
+typedef void *EGLNativeDisplayType;
+typedef void *EGLNativePixmapType;
+
+struct Genode_egl_window
+{
+	int width;
+	int height;
+	unsigned char *addr;
+};
+
+typedef struct Genode_egl_window *EGLNativeWindowType;
+
 #elif defined(__unix__)
 
 #ifdef MESA_EGL_NO_X11_HEADERS
diff --git a/src/egl/main/egldisplay.c b/src/egl/main/egldisplay.c
index 97ad865..061d2e7 100644
--- a/src/egl/main/egldisplay.c
+++ b/src/egl/main/egldisplay.c
@@ -74,7 +74,8 @@ static const struct {
    { _EGL_PLATFORM_DRM, "drm" },
    { _EGL_PLATFORM_FBDEV, "fbdev" },
    { _EGL_PLATFORM_NULL, "null" },
-   { _EGL_PLATFORM_ANDROID, "android" }
+   { _EGL_PLATFORM_ANDROID, "android" },
+   { _EGL_PLATFORM_GENODE, "genode" },
 };
 
 
diff --git a/src/egl/main/egldisplay.h b/src/egl/main/egldisplay.h
index 66aaff5..45a0b60 100644
--- a/src/egl/main/egldisplay.h
+++ b/src/egl/main/egldisplay.h
@@ -46,6 +46,7 @@ enum _egl_platform_type {
    _EGL_PLATFORM_FBDEV,
    _EGL_PLATFORM_NULL,
    _EGL_PLATFORM_ANDROID,
+   _EGL_PLATFORM_GENODE,
 
    _EGL_NUM_PLATFORMS,
    _EGL_INVALID_PLATFORM = -1
diff --git a/src/egl/main/egldriver.c b/src/egl/main/egldriver.c
index 0af8ab8..d049c9b 100644
--- a/src/egl/main/egldriver.c
+++ b/src/egl/main/egldriver.c
@@ -128,7 +128,11 @@ close_library(void *lib)
 static const char *
 library_suffix(void)
 {
+#ifdef GENODE_EGL_PLATFORM
+   return ".lib.so";
+#else
    return ".so";
+#endif
 }
 
 
@@ -352,7 +356,11 @@ _eglLoaderFile(const char *dir, size_t len, void *loader_data)
       }
    }
 
-#if defined(_EGL_OS_UNIX)
+/*
+ * 'access()' is not implemented yet for Genode and we don't want to provide the
+ * shared lib in a file system anyway.
+ */
+#if defined(_EGL_OS_UNIX) && (_EGL_NATIVE_PLATFORM != _EGL_PLATFORM_GENODE)
    /* check if the file exists */
    if (access(path, F_OK))
       return EGL_TRUE;
diff --git a/src/gallium/state_trackers/egl/common/egl_g3d.c b/src/gallium/state_trackers/egl/common/egl_g3d.c
index 7cc4e8f..5a7fae8 100644
--- a/src/gallium/state_trackers/egl/common/egl_g3d.c
+++ b/src/gallium/state_trackers/egl/common/egl_g3d.c
@@ -143,6 +143,12 @@ egl_g3d_get_platform(_EGLDriver *drv, _EGLPlatformType plat)
          nplat = native_get_android_platform(&egl_g3d_native_event_handler);
 #endif
          break;
+      case _EGL_PLATFORM_GENODE:
+         plat_name = "Genode";
+#ifdef HAVE_GENODE_BACKEND
+         nplat = native_get_genode_platform(&egl_g3d_native_event_handler);
+#endif
+         break;
       default:
          break;
       }
diff --git a/src/gallium/state_trackers/egl/genode/native_genode.cc b/src/gallium/state_trackers/egl/genode/native_genode.cc
new file mode 100644
index 0000000..7e8f88f
--- /dev/null
+++ b/src/gallium/state_trackers/egl/genode/native_genode.cc
@@ -0,0 +1,242 @@
+#if 0
+
+/*
+ * Mesa 3-D graphics library
+ *
+ * Copyright (C) 2011 LunarG Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Chia-I Wu <olv@lunarg.com>
+ */
+
+/**
+ * For NULL window system,
+ *
+ *  - the only valid native display is EGL_DEFAULT_DISPLAY
+ *  - there is no window or pixmap
+ */
+
+#include "util/u_memory.h"
+#include "null/null_sw_winsys.h"
+#include "common/native.h"
+
+struct null_display {
+   struct native_display base;
+
+   const struct native_event_handler *event_handler;
+
+   struct native_config *configs;
+   int num_configs;
+};
+
+static INLINE struct null_display *
+null_display(const struct native_display *ndpy)
+{
+   return (struct null_display *) ndpy;
+}
+
+static const struct native_config **
+null_display_get_configs(struct native_display *ndpy, int *num_configs)
+{
+   struct null_display *null = null_display(ndpy);
+   const struct native_config **configs;
+   int i;
+
+   configs = MALLOC(sizeof(*configs) * null->num_configs);
+   if (configs) {
+      for (i = 0; i < null->num_configs; i++)
+         configs[i] = &null->configs[i];
+      if (num_configs)
+         *num_configs = null->num_configs;
+   }
+
+   return configs;
+}
+
+static int
+null_display_get_param(struct native_display *ndpy,
+                      enum native_param_type param)
+{
+   return 0;
+}
+
+static void
+null_display_destroy(struct native_display *ndpy)
+{
+   struct null_display *null = null_display(ndpy);
+
+   FREE(null->configs);
+   ndpy_uninit(&null->base);
+   FREE(null);
+}
+
+static boolean
+null_display_init_config(struct native_display *ndpy)
+{
+   const enum pipe_format color_formats[] =  {
+      PIPE_FORMAT_B8G8R8A8_UNORM,
+      PIPE_FORMAT_B8G8R8X8_UNORM,
+      PIPE_FORMAT_B5G6R5_UNORM,
+      PIPE_FORMAT_NONE
+   };
+   struct null_display *null = null_display(ndpy);
+   int i;
+
+   null->configs = CALLOC(Elements(color_formats) - 1, sizeof(*null->configs));
+   if (!null->configs)
+      return FALSE;
+
+   /* add configs */
+   for (i = 0; color_formats[i] != PIPE_FORMAT_NONE; i++) {
+      if (null->base.screen->is_format_supported(null->base.screen,
+               color_formats[i], PIPE_TEXTURE_2D, 0,
+               PIPE_BIND_RENDER_TARGET)) {
+         struct native_config *nconf = &null->configs[null->num_configs];
+
+         nconf->color_format = color_formats[i];
+         nconf->buffer_mask = 1 << NATIVE_ATTACHMENT_BACK_LEFT;
+         null->num_configs++;
+      }
+   }
+
+   return TRUE;
+}
+
+static boolean
+null_display_init_screen(struct native_display *ndpy)
+{
+   struct null_display *null = null_display(ndpy);
+   struct sw_winsys *ws;
+
+   ws = null_sw_create();
+   if (!ws)
+      return FALSE;
+
+   null->base.screen = null->event_handler->new_sw_screen(&null->base, ws);
+   if (!null->base.screen) {
+      if (ws->destroy)
+         ws->destroy(ws);
+      return FALSE;
+   }
+
+   if (!null_display_init_config(&null->base)) {
+      ndpy_uninit(&null->base);
+      return FALSE;
+   }
+
+   return TRUE;
+}
+
+static struct native_display *
+null_display_create(const struct native_event_handler *event_handler)
+{
+   struct null_display *null;
+
+   null = CALLOC_STRUCT(null_display);
+   if (!null)
+      return NULL;
+
+   null->event_handler = event_handler;
+
+   null->base.init_screen = null_display_init_screen;
+   null->base.destroy = null_display_destroy;
+   null->base.get_param = null_display_get_param;
+   null->base.get_configs = null_display_get_configs;
+
+   return &null->base;
+}
+
+static const struct native_event_handler *null_event_handler;
+
+static struct native_display *
+native_create_display(void *dpy, boolean use_sw)
+{
+   struct native_display *ndpy = NULL;
+
+   /* the only valid display is NULL */
+   if (!dpy)
+      ndpy = null_display_create(null_event_handler);
+
+   return ndpy;
+}
+
+#endif
+
+
+
+
+
+#include "common/native.h"
+
+
+static struct native_display *
+native_create_display(void *dpy, boolean use_sw)
+{
+	/*
+	 * Request API by dynamically loading the driver module. Each driver
+	 * module has an entry-point function called 'drm_api_create'. For the
+	 * i915 driver, this function resides in
+	 * 'gallium/winsys/drm/intel/gem/intel_drm_api.c'.
+	 */
+	drm_api *api = 0;
+
+	const char *driver_filename = probe_gpu_and_select_driver();
+	void *driver_so_handle = driver_filename ? dlopen(driver_filename, 0) : 0;
+	if (driver_so_handle) {
+
+		/* query entry point into driver module */
+		drm_api *(*drm_api_create) (void) = 0;
+		drm_api_create = (drm_api *(*)(void))dlsym(driver_so_handle, "drm_api_create");
+		if (drm_api_create)
+			api = drm_api_create();
+		else
+			PWRN("could not obtain symbol \"drm_api_create\" in driver \"%s\"",
+			     driver_filename);
+	}
+
+	if (!api) {
+		PWRN("falling back to softpipe driver");
+
+		/*
+		 * Performing clflush is not needed when using software rendering.
+		 * Furthermore, on qemu with the default cpu, 'cflush' is an illegal
+		 * instruction.
+		 */
+		do_clflush = false;
+	}
+
+	return new (env()->heap()) Display(api);
+}
+
+
+static const struct native_platform genode_platform = {
+   "Genode", /* name */
+   native_create_display
+};
+
+
+extern "C" const struct native_platform *
+native_get_genode_platform(const struct native_event_handler *event_handler)
+{
+   /*null_event_handler = event_handler;*/
+   return &genode_platform;
+}
+
diff --git a/src/gallium/targets/egl-static/egl.c b/src/gallium/targets/egl-static/egl.c
index f19f024..c6b5d2f 100644
--- a/src/gallium/targets/egl-static/egl.c
+++ b/src/gallium/targets/egl-static/egl.c
@@ -96,7 +96,10 @@ loader_init(void)
    egl_g3d_loader.create_drm_screen = create_drm_screen;
    egl_g3d_loader.create_sw_screen = create_sw_screen;
 
+#ifndef GENODE_EGL_PLATFORM
+   /* the Genode port uses a different driver loading mechanism */
    loader_set_logger(_eglLog);
+#endif
 
    return &egl_g3d_loader;
 }
