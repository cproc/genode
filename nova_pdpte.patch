nova_pdpte.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>


---
 include/mtd.hpp  |    1 +
 include/utcb.hpp |    1 +
 include/vmx.hpp  |    5 ++++-
 src/ec_vmx.cpp   |   39 +++++++++++++++++++++++++++++++++++++++
 src/utcb.cpp     |   14 ++++++++++++++
 5 files changed, 59 insertions(+), 1 deletion(-)

diff --git a/include/mtd.hpp b/include/mtd.hpp
index d4b47a0..4625255 100644
--- a/include/mtd.hpp
+++ b/include/mtd.hpp
@@ -50,6 +50,7 @@ class Mtd
             STA             = 1UL << 18,
             TSC             = 1UL << 19,
             EFER            = 1UL << 20,
+            PDPTE           = 1UL << 21,
             FPU             = 1UL << 31,
         };
 
diff --git a/include/utcb.hpp b/include/utcb.hpp
index dc57bc7..c91fa99 100644
--- a/include/utcb.hpp
+++ b/include/utcb.hpp
@@ -76,6 +76,7 @@ class Utcb_data
                 uint32          ctrl[2];
                 uint64          reserved;
                 mword           cr0, cr2, cr3, cr4;
+                uint64          pdpte[4];
 #ifdef __x86_64__
                 mword           cr8, efer;
 #endif
diff --git a/include/vmx.hpp b/include/vmx.hpp
index 81b9d1e..ed8f67a 100644
--- a/include/vmx.hpp
+++ b/include/vmx.hpp
@@ -139,7 +139,10 @@ class Vmcs
             GUEST_DEBUGCTL_HI       = 0x2803ul,
             GUEST_EFER              = 0x2806ul,
             GUEST_PERF_GLOBAL_CTRL  = 0x2808ul,
-            GUEST_PDPTE             = 0x280aul,
+            GUEST_PDPTE0            = 0x280aul,
+            GUEST_PDPTE1            = 0x280cul,
+            GUEST_PDPTE2            = 0x280eul,
+            GUEST_PDPTE3            = 0x2810ul,
 
             // 64-Bit Host State
             HOST_EFER               = 0x2c02ul,
diff --git a/src/ec_vmx.cpp b/src/ec_vmx.cpp
index de5f09b..e025167 100644
--- a/src/ec_vmx.cpp
+++ b/src/ec_vmx.cpp
@@ -113,8 +113,47 @@ void Ec::vmx_cr()
 
     switch (acc) {
         case 0:     // MOV to CR
+        {
+            mword old_cr0 = current->regs.read_cr<Vmcs>(0);
+            mword old_cr4 = current->regs.read_cr<Vmcs>(4);
+
             current->regs.write_cr<Vmcs> (cr, current->regs.vmx_read_gpr (gpr));
+
+            /*
+             * Let the VMM update the PDPTE registers if necessary
+             * (Intel manual sections 4.4.1 of Vol. 3A and 26.3.2.4 of Vol. 3C)
+             */
+
+            /* no update needed if nested paging is not enabled */
+            if (!current->regs.nst_on)
+                break;
+
+            mword cr0 = current->regs.read_cr<Vmcs>(0);
+            mword cr4 = current->regs.read_cr<Vmcs>(4);
+
+            /* no update needed if not in protected mode with paging and PAE enabled */
+            if (!((cr0 & Cpu::CR0_PE) &&
+                  (cr0 & Cpu::CR0_PG) &&
+                  (cr4 & Cpu::CR4_PAE)))
+                break;
+
+            /* no update needed if no relevant bits of CR0 or CR4 have changed */
+            if ((cr != 3) &&
+                ((cr0 & Cpu::CR0_CD) == (old_cr0 & Cpu::CR0_CD)) &&
+                ((cr0 & Cpu::CR0_NW) == (old_cr0 & Cpu::CR0_NW)) &&
+                ((cr0 & Cpu::CR0_PG) == (old_cr0 & Cpu::CR0_PG)) &&
+                ((cr4 & Cpu::CR4_PAE) == (old_cr4 & Cpu::CR4_PAE)) &&
+                ((cr4 & Cpu::CR4_PGE) == (old_cr4 & Cpu::CR4_PGE)) &&
+                ((cr4 & Cpu::CR4_PSE) == (old_cr4 & Cpu::CR4_PSE)) &&
+                ((cr4 & Cpu::CR4_SMEP) == (old_cr4 & Cpu::CR4_SMEP)))
+               break;
+
+            /* PDPTE register update necessary */
+            current->regs.dst_portal = Vmcs::VMX_CR;
+            send_msg<ret_user_vmresume>();
+
             break;
+        }
         case 1:     // MOV from CR
             assert (cr != 0 && cr != 4);
             current->regs.vmx_write_gpr (gpr, current->regs.read_cr<Vmcs> (cr));
diff --git a/src/utcb.cpp b/src/utcb.cpp
index 91584da..ceb6727 100644
--- a/src/utcb.cpp
+++ b/src/utcb.cpp
@@ -200,6 +200,13 @@ bool Utcb::load_vmx (Cpu_regs *regs)
         efer = Vmcs::read (Vmcs::GUEST_EFER);
 #endif
 
+    if (m & Mtd::PDPTE) {
+        pdpte[0] = Vmcs::read (Vmcs::GUEST_PDPTE0);
+        pdpte[1] = Vmcs::read (Vmcs::GUEST_PDPTE1);
+        pdpte[2] = Vmcs::read (Vmcs::GUEST_PDPTE2);
+        pdpte[3] = Vmcs::read (Vmcs::GUEST_PDPTE3);
+    }
+
     barrier();
     mtd = m;
     items = sizeof (Utcb_data) / sizeof (mword);
@@ -346,6 +353,13 @@ bool Utcb::save_vmx (Cpu_regs *regs)
         regs->write_efer<Vmcs> (efer);
 #endif
 
+    if (mtd & Mtd::PDPTE) {
+        Vmcs::write (Vmcs::GUEST_PDPTE0, pdpte[0]);
+        Vmcs::write (Vmcs::GUEST_PDPTE1, pdpte[1]);
+        Vmcs::write (Vmcs::GUEST_PDPTE2, pdpte[2]);
+        Vmcs::write (Vmcs::GUEST_PDPTE3, pdpte[3]);
+    }
+
     return mtd & Mtd::FPU;
 }
 
