commit be41215acda6a2c1f6d6c000719f9bbdef548e80
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Wed Oct 30 17:16:29 2019 +0100

    debug.diff

diff --git a/.gitignore b/.gitignore
index 52c51cf..173d84c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,2 @@
 patches-master
+*.swp
diff --git a/drivers/base/component.c b/drivers/base/component.c
index 4eb062f..f825417 100644
--- a/drivers/base/component.c
+++ b/drivers/base/component.c
@@ -309,7 +309,7 @@ int component_master_add_with_match(struct device *dev,
 {
 	struct master *master;
 	int ret;
-
+lx_printf("component_master_add_with_match(): match->num: %zu\n", match->num);
 	/* Reallocate the match array for its true size */
 	ret = component_match_realloc(dev, match, match->num);
 	if (ret)
@@ -448,18 +448,25 @@ int component_bind_all(struct device *master_dev, void *data)
 	WARN_ON(!mutex_is_locked(&component_mutex));
 
 	master = __master_find(master_dev, NULL);
-printk("*** component_bind_all(): master: %p\n", master);
+
+printk("component_bind_all(): master: %p\n", master);
 	if (!master)
 		return -EINVAL;
 
 	/* Bind components in match order */
-	for (i = 0; i < master->match->num; i++)
+	for (i = 0; i < master->match->num; i++) {
+		lx_printf("component_bind_all(): %zu, device: %s, duplicate: %u\n",
+		          i,
+		          master->match->compare[i].component->dev->name,
+		          master->match->compare[i].duplicate);
 		if (!master->match->compare[i].duplicate) {
 			c = master->match->compare[i].component;
+			lx_printf("component_bind_all(): trying to bind %s\n", c->dev->name);
 			ret = component_bind(c, master, data);
 			if (ret)
 				break;
 		}
+	}
 
 	if (ret != 0) {
 		for (; i--; )
@@ -468,7 +475,7 @@ printk("*** component_bind_all(): master: %p\n", master);
 				component_unbind(c, master, data);
 			}
 	}
-printk("*** component_bind_all() finished\n");
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(component_bind_all);
diff --git a/drivers/gpu/drm/drm_atomic_helper.c b/drivers/gpu/drm/drm_atomic_helper.c
index 1ad2b23..c3d0da6 100644
--- a/drivers/gpu/drm/drm_atomic_helper.c
+++ b/drivers/gpu/drm/drm_atomic_helper.c
@@ -27,6 +27,7 @@
 
 #include <drm/drmP.h>
 #include <drm/drm_atomic.h>
+#include <drm/drm_blend.h>
 #include <drm/drm_plane_helper.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_atomic_helper.h>
diff --git a/drivers/gpu/drm/drm_fourcc.c b/drivers/gpu/drm/drm_fourcc.c
index f92f18c..676b63b 100644
--- a/drivers/gpu/drm/drm_fourcc.c
+++ b/drivers/gpu/drm/drm_fourcc.c
@@ -221,10 +221,10 @@ drm_get_format_info(struct drm_device *dev,
 		    const struct drm_mode_fb_cmd2 *mode_cmd)
 {
 	const struct drm_format_info *info = NULL;
-
+#if 0 /* XXX: dev->mode_config.funcs is set by dcss_crtc_bind() */
 	if (dev->mode_config.funcs->get_format_info)
 		info = dev->mode_config.funcs->get_format_info(mode_cmd);
-
+#endif
 	if (!info)
 		info = drm_format_info(mode_cmd->pixel_format);
 
diff --git a/drivers/gpu/drm/drm_mm.c b/drivers/gpu/drm/drm_mm.c
index 1acf3b1..7fd72a0 100644
--- a/drivers/gpu/drm/drm_mm.c
+++ b/drivers/gpu/drm/drm_mm.c
@@ -48,6 +48,7 @@
 #include <linux/seq_file.h>
 #include <linux/export.h>
 #include <linux/interval_tree_generic.h>
+#include <linux/math64.h>
 
 /**
  * DOC: Overview
diff --git a/drivers/gpu/drm/drm_modeset_helper.c b/drivers/gpu/drm/drm_modeset_helper.c
index f1c24ab..c667447 100644
--- a/drivers/gpu/drm/drm_modeset_helper.c
+++ b/drivers/gpu/drm/drm_modeset_helper.c
@@ -21,9 +21,15 @@
  */
 
 #include <drm/drm_atomic_helper.h>
+#include <drm/drm_connector.h>
 #include <drm/drm_crtc_helper.h>
+#include <drm/drm_device.h>
 #include <drm/drm_fb_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_framebuffer.h>
 #include <drm/drm_modeset_helper.h>
+#include <drm/drm_rect.h>
+#include <drm/drm_plane.h>
 #include <drm/drm_plane_helper.h>
 
 /**
diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 6105404..4f8b733 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -112,6 +112,8 @@ int drm_of_component_probe_with_match(struct device *dev,
 	struct device_node *ep, *port, *remote;
 	int i;
 
+printk("drm_of_component_probe_with_match(): %s\n", dev->of_node->name);
+
 	if (!dev->of_node)
 		return -EINVAL;
 
@@ -123,12 +125,12 @@ int drm_of_component_probe_with_match(struct device *dev,
 		port = of_parse_phandle(dev->of_node, "ports", i);
 		if (!port)
 			break;
-
+printk("drm_of_component_probe_with_match(): port: %s, port->parent: %s\n", port->name, port->parent->name);
 		if (!of_device_is_available(port->parent)) {
 			of_node_put(port);
 			continue;
 		}
-
+lx_printf("drm_of_component_probe_with_match(): adding match: %s\n", port->name);
 		drm_of_component_match_add(dev, &match, compare_of, port);
 		of_node_put(port);
 	}
@@ -155,9 +157,11 @@ int drm_of_component_probe_with_match(struct device *dev,
 			of_node_put(port);
 			continue;
 		}
-
+lx_printf("drm_of_component_probe_with_match(): calling for_each_child_of_node()\n");
 		for_each_child_of_node(port, ep) {
+lx_printf("drm_of_component_probe_with_match(): for_each_child_of_node()\n");
 			remote = of_graph_get_remote_port_parent(ep);
+lx_printf("drm_of_component_probe_with_match(): remote: %s, remote->parent: %s\n", remote->name, remote->parent->name);
 			if (!remote || !of_device_is_available(remote)) {
 				of_node_put(remote);
 				continue;
@@ -167,7 +171,7 @@ int drm_of_component_probe_with_match(struct device *dev,
 				of_node_put(remote);
 				continue;
 			}
-
+lx_printf("drm_of_component_probe_with_match(): adding match 2: %s\n", remote->name);
 			drm_of_component_match_add(dev, &match, compare_of,
 						   remote);
 			of_node_put(remote);
diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 3bd4312..30d4ac4 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -39,6 +39,7 @@
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_edid.h>
 #include <drm/drm_modeset_helper_vtables.h>
+#include <drm/drm_encoder.h>
 
 #include "drm_crtc_helper_internal.h"
 
diff --git a/drivers/gpu/drm/drm_vblank.c b/drivers/gpu/drm/drm_vblank.c
index c2f23a6..f1bc5df 100644
--- a/drivers/gpu/drm/drm_vblank.c
+++ b/drivers/gpu/drm/drm_vblank.c
@@ -27,6 +27,7 @@
 #include <drm/drm_vblank.h>
 #include <drm/drmP.h>
 #include <linux/export.h>
+#include <linux/math64.h>
 
 #include "drm_trace.h"
 #include "drm_internal.h"
diff --git a/drivers/gpu/drm/imx/dcss/dcss-crtc.c b/drivers/gpu/drm/imx/dcss/dcss-crtc.c
index b8ccf2e..9ab48f9 100644
--- a/drivers/gpu/drm/imx/dcss/dcss-crtc.c
+++ b/drivers/gpu/drm/imx/dcss/dcss-crtc.c
@@ -469,7 +469,7 @@ static int dcss_crtc_bind(struct device *dev, struct device *master,
 	struct drm_device *drm = data;
 	struct dcss_crtc *crtc;
 	int ret;
-
+lx_printf("### dcss_crtc_bind(): dev: %s, master: %s\n", dev_name(dev), dev_name(master));
 	crtc = devm_kzalloc(dev, sizeof(*crtc), GFP_KERNEL);
 	if (!crtc)
 		return -ENOMEM;
@@ -501,13 +501,17 @@ static const struct component_ops dcss_crtc_ops = {
 static int dcss_crtc_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-
+lx_printf("### dcss_crtc_probe()\n");
 	if (!dev->platform_data) {
 		dev_err(dev, "no platform data\n");
 		return -EINVAL;
 	}
 
-	return component_add(dev, &dcss_crtc_ops);
+	int ret = component_add(dev, &dcss_crtc_ops);
+
+lx_printf("dcss_crtc_probe() finished\n");
+
+	return ret;
 }
 
 static int dcss_crtc_remove(struct platform_device *pdev)
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.c b/drivers/gpu/drm/imx/hdp/imx-hdp.c
index bcfad52..2b1dffc 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.c
@@ -929,12 +929,12 @@ imx_hdp_connector_mode_valid(struct drm_connector *connector,
 		if (mode->clock > 297000)
 			return MODE_CLOCK_HIGH;
 	}
-
+#if 0
 	/* For iMX8QM A0 Max support video mode is 4kp30 */
 	if (cpu_is_imx8qm() && (imx8_get_soc_revision() < B0_SILICON_ID))
 		if (mode->clock > 297000)
 			return MODE_CLOCK_HIGH;
-
+#endif
 	/* MAX support pixel clock rate 594MHz */
 	if (mode->clock > 594000)
 		return MODE_CLOCK_HIGH;
@@ -1438,6 +1438,8 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 	u8 hpd;
 	int ret;
 
+lx_printf("### imx_hdp_imx_bind(): dev: %s, master: %s\n", dev_name(dev), dev_name(master));
+
 	if (!pdev->dev.of_node)
 		return -ENODEV;
 
@@ -1490,11 +1492,11 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 				      "fsl,use_digpll_pclock");
 
 	hdp->no_edid = of_property_read_bool(pdev->dev.of_node, "fsl,no_edid");
-
+#if 0
 	/* EDID function is not supported by iMX8QM A0 */
 	if (cpu_is_imx8qm() && (imx8_get_soc_revision() < B0_SILICON_ID))
 		hdp->no_edid = true;
-
+#endif
 	if (devtype->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
 		hdp->is_dp = true;
 		hdp->is_edp = of_property_read_bool(pdev->dev.of_node, "fsl,edp");
@@ -1702,7 +1704,10 @@ static const struct component_ops imx_hdp_imx_ops = {
 
 static int imx_hdp_imx_probe(struct platform_device *pdev)
 {
-	return component_add(&pdev->dev, &imx_hdp_imx_ops);
+	lx_printf("### imx_hdp_imx_probe()\n");
+	int res = component_add(&pdev->dev, &imx_hdp_imx_ops);
+	lx_printf("imx_hdp_imx_probe() finished\n");
+	return res;
 }
 
 static int imx_hdp_imx_remove(struct platform_device *pdev)
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.h b/drivers/gpu/drm/imx/hdp/imx-hdp.h
index 613bd7b..8a516d1 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.h
@@ -25,6 +25,8 @@
 #include <drm/drm_atomic.h>
 #include <soc/imx8/sc/sci.h>
 #include <soc/imx8/sc/scfw.h>
+#include <soc/imx8/sc/types.h>
+
 
 #include <drm/drm_dp_helper.h>
 #include "../../../../mxc/hdp/all.h"
diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 76b782c..7927255 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -16,6 +16,7 @@
 #include <linux/component.h>
 #include <linux/device.h>
 #include <linux/module.h>
+#include <linux/mod_devicetable.h>
 #include <linux/platform_device.h>
 #include <drm/drmP.h>
 #include <drm/drm_atomic.h>
@@ -23,6 +24,7 @@
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_encoder.h>
 #include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_plane_helper.h>
 #include <drm/drm_of.h>
@@ -43,7 +45,9 @@ static void imx_drm_driver_lastclose(struct drm_device *drm)
 {
 	struct imx_drm_device *imxdrm = drm->dev_private;
 
+#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 	drm_fbdev_cma_restore_mode(imxdrm->fbhelper);
+#endif
 }
 
 DEFINE_DRM_GEM_CMA_FOPS(imx_drm_driver_fops);
@@ -120,6 +124,19 @@ static int compare_of(struct device *dev, void *data)
 {
 	struct device_node *np = data;
 
+	lx_printf("compare_of(): %s, %s, %p, %p\n", dev->driver->name, np->name, dev->of_node, data);
+
+	if ((strncmp(dev->driver->name, "imx-dcss-crtc", strlen(dev->driver->name)) == 0) &&
+	    (strncmp(np->name, "port", strlen(np->name)) == 0))
+		return 1;
+
+	if ((strncmp(dev->driver->name, "i.mx8-hdp", strlen(dev->driver->name)) == 0) &&
+	    (strncmp(np->name, "hdmi", strlen(np->name)) == 0))
+		return 1;
+
+	return 0;
+
+#if 0
 	/* Special case for DI, dev->of_node may not be set yet */
 	if (strcmp(dev->driver->name, "imx-ipuv3-crtc") == 0) {
 		struct ipu_client_platformdata *pdata = dev->platform_data;
@@ -161,6 +178,7 @@ static int compare_of(struct device *dev, void *data)
 	}
 
 	return dev->of_node == np;
+#endif
 }
 
 static const char *const imx_drm_dpu_comp_parents[] = {
@@ -202,12 +220,14 @@ static bool imx_drm_parent_is_compatible(struct device *dev,
 
 static inline bool has_dpu(struct device *dev)
 {
+lx_printf("has_dpu()\n");
 	return imx_drm_parent_is_compatible(dev, imx_drm_dpu_comp_parents,
 					ARRAY_SIZE(imx_drm_dpu_comp_parents));
 }
 
 static inline bool has_dcss(struct device *dev)
 {
+lx_printf("has_dcss()\n");
 	return imx_drm_parent_is_compatible(dev, imx_drm_dcss_comp_parents,
 					ARRAY_SIZE(imx_drm_dcss_comp_parents));
 }
@@ -416,8 +436,10 @@ static void imx_drm_unbind(struct device *dev)
 
 	drm_kms_helper_poll_fini(drm);
 
+#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 	if (imxdrm->fbhelper)
 		drm_fbdev_cma_fini(imxdrm->fbhelper);
+#endif
 
 	drm_mode_config_cleanup(drm);
 
@@ -442,7 +464,7 @@ static int imx_drm_platform_probe(struct platform_device *pdev)
 {
 	struct component_match *match = NULL;
 	int ret;
-printk("*** imx_drm_platform_probe(): %p\n", __builtin_return_address(0));
+lx_printf("### imx_drm_platform_probe()\n");
 	if (has_dpu(&pdev->dev))
 		add_dpu_bliteng_components(&pdev->dev, &match);
 
@@ -451,6 +473,7 @@ printk("*** imx_drm_platform_probe(): %p\n", __builtin_return_address(0));
 
 	if (!ret)
 		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+lx_printf("imx_drm_platform_probe() finished\n");
 
 	return ret;
 }
diff --git a/drivers/gpu/imx/dcss/dcss-blkctl.c b/drivers/gpu/imx/dcss/dcss-blkctl.c
index 2f13b33..6dd6e1c 100644
--- a/drivers/gpu/imx/dcss/dcss-blkctl.c
+++ b/drivers/gpu/imx/dcss/dcss-blkctl.c
@@ -115,10 +115,10 @@ int dcss_blkctl_init(struct dcss_soc *dcss, unsigned long blkctl_base)
 	disp_dev = of_get_property(node, "disp-dev", &len);
 	if (!disp_dev || !strncmp(disp_dev, "hdmi_disp", 9))
 		blkctl->hdmi_output = true;
-
+#if 0
 	if (imx8_get_soc_revision() >= B0_SILICON_ID)
 		blkctl->clk_setting = HDMI_MIPI_CLK_SEL;
-
+#endif
 	dcss_blkctl_cfg(dcss);
 
 	return 0;
diff --git a/drivers/gpu/imx/dcss/dcss-common.c b/drivers/gpu/imx/dcss/dcss-common.c
index 8f292db..5e0bd81 100644
--- a/drivers/gpu/imx/dcss/dcss-common.c
+++ b/drivers/gpu/imx/dcss/dcss-common.c
@@ -44,7 +44,7 @@ struct dcss_devtype {
 	u32 pll_base;
 };
 
-static struct dcss_devtype dcss_type_imx8m = {
+/*static*/ struct dcss_devtype dcss_type_imx8m = {
 	.name = "DCSS_imx8m",
 	.blkctl_ofs = 0x2F000,
 	.ctxld_ofs = 0x23000,
@@ -568,7 +568,7 @@ static int dcss_probe(struct platform_device *pdev)
 	struct resource *res;
 	struct dcss_soc *dcss;
 	const struct dcss_devtype *devtype;
-
+lx_printf("### dcss_probe()\n");
 	devtype = of_device_get_match_data(&pdev->dev);
 	if (!devtype) {
 		dev_err(&pdev->dev, "no device match found\n");
@@ -610,7 +610,11 @@ static int dcss_probe(struct platform_device *pdev)
 
 	dcss_bus_freq(dcss, true);
 
-	return dcss_add_client_devices(dcss);
+	ret = dcss_add_client_devices(dcss);
+
+lx_printf("dcss_probe() finished\n");
+
+	return ret;
 }
 
 static int dcss_remove(struct platform_device *pdev)
diff --git a/drivers/gpu/imx/dcss/dcss-scaler.c b/drivers/gpu/imx/dcss/dcss-scaler.c
index 051bc4b..fc7b2e3 100644
--- a/drivers/gpu/imx/dcss/dcss-scaler.c
+++ b/drivers/gpu/imx/dcss/dcss-scaler.c
@@ -332,7 +332,7 @@ static int dcss_scaler_ch_init_all(struct dcss_soc *dcss,
 
 		ch->base_ofs = scaler_base + i * 0x400;
 
-		ch->base_reg = devm_ioremap(dcss->dev, ch->base_ofs, SZ_4K);
+		ch->base_reg = devm_ioremap(dcss->dev, ch->base_ofs, 0x400);
 		if (!ch->base_reg) {
 			dev_err(dcss->dev, "scaler: unable to remap ch base\n");
 			return -ENOMEM;
diff --git a/include/linux/fb.h b/include/linux/fb.h
index bc24e48..5cc1e2a 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -461,6 +461,16 @@ struct fb_tile_ops {
    output like oopses */
 #define FBINFO_CAN_FORCE_OUTPUT     0x200000
 
+struct aperture {
+	resource_size_t base;
+	resource_size_t size;
+};
+
+struct apertures_struct {
+	unsigned int count;
+	struct aperture ranges[0];
+};
+
 struct fb_info {
 	atomic_t count;
 	int node;
@@ -514,19 +524,13 @@ struct fb_info {
 	/* we need the PCI or similar aperture base/size not
 	   smem_start/size as smem_start may just be an object
 	   allocated inside the aperture so may not actually overlap */
-	struct apertures_struct {
-		unsigned int count;
-		struct aperture {
-			resource_size_t base;
-			resource_size_t size;
-		} ranges[0];
-	} *apertures;
+	struct apertures_struct *apertures;
 
 	bool skip_vt_switch; /* no VT switch on suspend/resume required */
 };
 
 static inline struct apertures_struct *alloc_apertures(unsigned int max_num) {
-	struct apertures_struct *a = kzalloc(sizeof(struct apertures_struct)
+	struct apertures_struct *a = (struct apertures_struct*)kzalloc(sizeof(struct apertures_struct)
 			+ max_num * sizeof(struct aperture), GFP_KERNEL);
 	if (!a)
 		return NULL;
