if {![have_spec foc] || ![have_spec 32bit]} {
	puts "\nThe Noux GDB scenario is supported on 32-bit Fiasco.OC only\n"
	exit 0
}

if {[have_spec arm]} {
	set gdb "gdb_arm"
	set tool_prefix "genode-arm-"
}

if {[have_spec x86]} {
	set gdb "gdb_x86"
	set tool_prefix "genode-x86-"
}

#
# Uncomment the following line when working on the GDB source code. Otherwise,
# the package may get recompiled, yet it does not get reinstalled into 'bin/'.
#
#exec rm -rf noux-pkg/$gdb/ bin/$gdb/

set build_components {
	core init drivers/timer noux lib/libc_noux
	drivers/uart
	server/terminal_mux server/terminal_crosslink
	server/terminal_log
	server/ram_fs app/gdb_monitor
	test/gdb_monitor
}
lappend build_components noux-pkg/$gdb

build $build_components

# tar archive for GDB

exec sh -c "find bin/$gdb/ -type f | (xargs [cross_dev_prefix]strip || true) 2>/dev/null"
exec tar cfhv bin/gdb.tar -C bin/$gdb .

# names of the binaries needed for the GDB monitor test

set test_binaries {
	test-gdb_monitor
	ld.lib.so
	libc.lib.so
	libc_log.lib.so
}

# tar archive for the unstripped binaries of the GDB monitor test

foreach test_binary $test_binaries {
	exec tar ufv bin/test-gdb_monitor.tar -h -C bin $test_binary
}

# tar archive for the source code of the GDB monitor test
# currently, directories need to have their own tar records 

exec mkdir -p bin/test-gdb_monitor-src
foreach test_binary $test_binaries {
	set source_files [ exec [cross_dev_prefix]objdump -dl bin/$test_binary | grep "^/.*:.*" | sed -e "s/:.*//" | uniq ]
	foreach source_file $source_files {
		# resolve '..' to avoid problems with 'tar' with parts like '/a/b/../'
		# where '/a' exists, but '/a/b' does not
		set source_file [file normalize $source_file]
		if [file exists $source_file] {
			set dirname [ exec dirname $source_file]
			exec mkdir -p bin/test-gdb_monitor-src$dirname
			exec ln -sf  $source_file bin/test-gdb_monitor-src$source_file
		}
	}
}
exec tar chf bin/test-gdb_monitor-src.tar -C bin/test-gdb_monitor-src .

create_boot_directory

append config {
	<config verbose="yes">
		<parent-provides>
			<service name="ROM"/>
			<service name="LOG"/>
			<service name="CAP"/>
			<service name="RAM"/>
			<service name="RM"/>
			<service name="CPU"/>
			<service name="PD"/>
			<service name="IRQ"/>
			<service name="IO_PORT"/>
			<service name="IO_MEM"/>
			<service name="SIGNAL"/>
		</parent-provides>
		<default-route>
			<any-service> <any-child/> <parent/> </any-service>
		</default-route>

		<start name="timer">
			<resource name="RAM" quantum="1M"/>
			<provides><service name="Timer"/></provides>
			<route> <any-service> <parent/> </any-service> </route>
		</start>

		<start name="uart_drv">}

# use kernel debugger as UART on Fiasco.OC
append_if [have_spec foc] config {
			<binary name="kdb_uart_drv"/>}

append config {
			<resource name="RAM" quantum="1M"/>
			<provides>
				<service name="Uart"/>
				<service name="Terminal"/>
			</provides>
			<config> }

# on Fiasco.OC the kdb_uart_drv is always UART 0
append_if [have_spec foc] config {
				<policy label="terminal_mux" uart="0" detect_size="yes"/> }

# on all other kernels, direct terminal_mux to UART 1 (Qemu stdio, see below)
append_if [expr ![have_spec foc]] config {
				<policy label="terminal_mux" uart="1" detect_size="yes"/> }

append config {
			</config>
			<route> <any-service> <parent/> <any-child/> </any-service> </route>
		</start>
		<start name="terminal_mux">
			<resource name="RAM" quantum="2M"/>
			<provides><service name="Terminal"/></provides>
			<route>
				<service name="Terminal"><child name="uart_drv"/></service>
				<any-service> <parent/> <any-child/> </any-service>
			</route>
			<config>
				<keyboard layout="de"/>
			</config>
		</start>
		<start name="terminal_log">
			<resource name="RAM" quantum="2M"/>
			<provides>
				<service name="LOG"/>
			</provides>
			<route>
				<any-service><child name="terminal_mux"/> <any-child/> <parent/> </any-service>
			</route>
		</start>
		<start name="terminal_gdb">
			<binary name="terminal_crosslink"/>
			<resource name="RAM" quantum="1M"/>
			<provides> <service name="Terminal"/> </provides>
		</start>
		<start name="gdb_monitor">
			<resource name="RAM" quantum="10M"/>
			<route>
				<service name="Terminal"><child name="terminal_gdb"/></service>
				<any-service> <any-child/> <parent/> </any-service>
			</route>
			<config>
				<target name="test-gdb_monitor"/>
				<preserve name="RAM" quantum="5M"/>
			</config>
		</start>
		<start name="ram_fs">
			<resource name="RAM" quantum="10M"/>
			<provides><service name="File_system"/></provides>
			<config>
				<content>
					<dir name="gdb">
						<inline name="commands">
							set interactive-mode off
							directory /gdb/src
							target remote /dev/gdb
							symbol-file /gdb/ld.lib.so
							b call_main
							c
							delete 1
							symbol-file /gdb/test-gdb_monitor
							b main
							set solib-search-path /gdb
							sharedlibrary
							c
							delete 2
							set interactive-mode auto
						</inline>
					</dir>
				</content>
				<!-- constrain sessions according to their labels -->
				<policy label="noux -> gdb" root="/gdb" />
			</config>
		</start>
		<start name="noux">
			<resource name="RAM" quantum="1G"/>
			<route>
				<service name="Terminal">
					<if-arg key="label" value=""/><child name="terminal_mux"/>
				</service>
				<service name="Terminal">
					<if-arg key="label" value="noux(terminal_fs)"/><child name="terminal_gdb"/>
				</service>
				<any-service> <any-child/> <parent/> </any-service>
			</route>
			<config>
				<fstab>
					<tar name="gdb.tar" at="/"/>
					<dir name="dev"><terminal name="gdb"/></dir>
					<dir name="gdb">
						<tar name="test-gdb_monitor.tar"/>
						<fs label="gdb"/>
						<dir name="src"> <tar name="test-gdb_monitor-src.tar"/> </dir>
					</dir>
				</fstab> }
append config "
				<start name=\"/bin/${tool_prefix}gdb\"> "
append config {
					<arg value="/gdb/test-gdb_monitor"/>
					<arg value="-x" /><arg value="/gdb/commands" />
				</start>
			</config>
		</start>
	</config>
}

install_config $config


#
# Boot modules
#

# generic modules
set boot_modules {
	core init timer ld.lib.so noux terminal_mux terminal_crosslink
	libc.lib.so libm.lib.so libc_noux.lib.so ncurses.lib.so expat.lib.so
	libc_lock_pipe.lib.so libc_log.lib.so libc_terminal.lib.so
	ram_fs gdb_monitor test-gdb_monitor terminal_log
	gdb.tar test-gdb_monitor.tar test-gdb_monitor-src.tar
}

# platform-specific modules
lappend_if [expr ![have_spec foc]] boot_modules uart_drv
lappend_if [have_spec foc]         boot_modules kdb_uart_drv

set fiasco_serial_esc_arg ""

build_boot_image $boot_modules

run_genode_until forever

exec rm bin/gdb.tar
